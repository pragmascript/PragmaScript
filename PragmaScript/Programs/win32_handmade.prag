import "handmade.prag"

// https://github.com/ecxr/handmadehero/blob/master/code/win32_handmade.cpp

// TODO: 
// - Saved game locations
// - Getting a handle to our own executable file
// - Asset loading pppath
// - Threading
// - Raw input
// - Sleep/timeBeginPeriod
// - ClipCursor for multimonitor support
// - Fullscreen support
// - WM_SETCURSOR (cursor visibility)
// - QueryCancelAutoplay
// - WM_ACTIATEAPP (when we are not active app)
// - Blit speed improvements (bitblit)
// - Hardware accelereration
// - GetKeyboardLayout (for internationalization)

let HANDMADE_INTERAL = false;
let DEBUG_DRAW_FPS = true;

let offscreen_buffer = struct
(
	info:   BITMAPINFO;
	memory: ptr;
	width:  i32;
	height: i32;
	pitch:  i32;
);
let window_info = struct 
(
	handle: mm;
	dc: mm;
	width: i32;
	height: i32;
);

var backbuffer: offscreen_buffer;
var window: window_info;
var window_requests_quit = false;

let sound_output = struct
(
	sound_buffer: IDirectSoundBuffer*;
	samples_per_second: i32;
	bytes_per_chunk: i32;
	buffer_size: i32;
	latency_byte_count: i32;
	buffer_start: ptr;
	
	byte_last_written: i32;
	last_play_cursor: i32;
	last_play_cursor_change_time: i64;
	next_write_positon: i32;
	next_bytes_to_write: i32;
	first_write: bool;
);


let kilobytes = fun (bytes: mm) => mm 
{
	return bytes * 1024 ;
}
let megabytes = fun (bytes: mm) => mm 
{
	return bytes * 1024 * 1024;
}
let gigabytes = fun (bytes: mm) => mm
{
	return bytes * 1024 * 1024 * 1024;
}
let terabytes = fun (bytes: mm) => mm
{
	return bytes * 1024 * 1024 * 1024 * 1024;
}

let platform_read_file = fun (name: string) => i8[] 
{
	var result: i8[];
	result.data = nullptr;
	result.length = 0;
	var handle = CreateFileA(cstr(name), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, 0);
	if (handle == null) {
		return result;
	}

	var size: i64 = 0;
	var fsr = GetFileSizeEx(handle, &size);
	if (fsr == 0 || size == 0) {
		CloseHandle(handle);
		return result;
	}

	var buffer = VirtualAlloc(nullptr, (mm)size, MEM_COMMIT, PAGE_READWRITE);
	if ((mm)buffer == null) {
		CloseHandle(handle);
		return result;
	}
	assert((mm)size <=\ gigabytes(4));
	var size_32 = (i32)size;
	var bytes_read: i32;
	var rfr = ReadFile(handle, buffer, size_32, &bytes_read,  nullptr);
	assert(bytes_read == size_32);
	if (rfr == 0) {
		VirtualFree(buffer, null, MEM_RELEASE);
		CloseHandle(handle);
		return result;		
	}

	result.data = buffer;
	result.length = size_32;
	CloseHandle(handle);
	return result;
} 

let platform_free_file_memory = fun (mem: ptr) => void {
	VirtualFree(mem, null, MEM_RELEASE);
}

let platform_write_file = fun (name: string; buffer: i8[]) => bool {
	var handle = CreateFileA(cstr(name), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, 0, 0);
	if (handle == null) {
		CloseHandle(handle);
		return false;
	}
	var bytes_written: i32 = 0;
	var result = WriteFile(handle, buffer.data, buffer.length, &bytes_written, nullptr);
	if (result != 0) {
		CloseHandle(handle);
		assert(buffer.length == bytes_written);
		return true;
	} else {
		CloseHandle(handle);
		return false;
	}

	CloseHandle(handle);
	return false;
}

let win_init_direct_sound = fun (hwnd: mm; buffer_size: i32; samples_per_second: i32) => IDirectSoundBuffer*
{ 
	var dsound_library = LoadLibraryA(cstr("dsound.dll\0"));
	assert((mm)dsound_library != null);

	var DirectSoundCreate: fun 
	(
		GuidDevice: ptr;
		ds: IDirectSound**;
		unused: ptr;
	) => i32;
	*((ptr*)(&DirectSoundCreate)) = (ptr)GetProcAddress(dsound_library, cstr("DirectSoundCreate\0"));
	assert((mm)DirectSoundCreate != null);

	var dsound_obj: IDirectSound*;
	assert(DirectSoundCreate(nullptr, &dsound_obj, nullptr) == DS_OK);
	assert(dsound_obj.vtable.SetCooperativeLevel(dsound_obj, hwnd, DSSCL_PRIORITY) == DS_OK);

	var desc_primary = DSBUFFERDESC { };
	desc_primary.flags = DSBCAPS_PRIMARYBUFFER;
	desc_primary.size = (i32)(sizeof(DSBUFFERDESC));
	desc_primary.bufferBytes = 0;
	desc_primary.reserved = 0;
	desc_primary.fxFormat = (WAVEFORMATEX*)nullptr;

	var primary_buffer: IDirectSoundBuffer*;
	assert(dsound_obj.vtable.CreateSoundBuffer(dsound_obj, &desc_primary, &primary_buffer, nullptr) == DS_OK);

	var wave_format = WAVEFORMATEX {};
	wave_format.formatTag = WAVE_FORMAT_PCM;
	wave_format.nChannels = 2;
	wave_format.nBitsPerSample = 16;
	wave_format.nSamplesPerSec = samples_per_second;
	wave_format.nBlockAlign = (wave_format.nChannels*wave_format.nBitsPerSample) / (i16)8;
	wave_format.nAvgBytesPerSec = wave_format.nSamplesPerSec * (i32)wave_format.nBlockAlign;
	wave_format.size = 0;
	assert(primary_buffer.vtable.SetFormat(primary_buffer, &wave_format) == DS_OK);

	var desc_secondary = DSBUFFERDESC { };
	desc_secondary.size = (i32)(sizeof(DSBUFFERDESC));
	desc_secondary.flags = 0;
	desc_secondary.bufferBytes = buffer_size;
	desc_secondary.fxFormat = &wave_format;
	desc_secondary.reserved = 0;

	var secondary_buffer: IDirectSoundBuffer*;
	assert(dsound_obj.vtable.CreateSoundBuffer(dsound_obj, &desc_secondary, &secondary_buffer, nullptr) == DS_OK);
	return secondary_buffer;
}

let win_clear_sound_buffer = fun
(
	sound_output: sound_output*;
) => void
{
	var region1: ptr;
	var region1_size: i32;
	var region2: ptr;
	var region2_size: i32;
	var sound_buffer = sound_output.sound_buffer;
	var error = sound_buffer.vtable.Lock(sound_buffer, 
		0, sound_output.buffer_size, 
		&region1, &region1_size,
		&region2, &region2_size,
		0);
	assert(error == DS_OK);
	var dest_sample = (i32*)region1;
	var sample_count = region1_size / sound_output.bytes_per_chunk;
	for (var i: i32 = 0; i < sample_count; ++i) {
		*dest_sample++ = 0;
	}
	sound_output.buffer_start = region1;
	assert(region2_size == 0);
	// dest_sample = (i32*)region2;
	// sample_count = region2_size / sound_output.bytes_per_chunk;
	// for (var i: i32 = 0; i < sample_count; ++i) {
	// 	*dest_sample++ = 0;
	// }
	error = sound_output.sound_buffer.vtable.Unlock(sound_buffer,
		region1, region1_size, 
		region2, region2_size);
	assert(error == DS_OK);
}

let win_fill_sound_buffer = fun 
(
	sound_output: sound_output*;
	game_sound_output: game_sound_output*;
) => void 
{
	var byte_lock_position = sound_output.next_write_positon;
	var bytes_to_write = sound_output.next_bytes_to_write;
	var region1: ptr;
	var region1_size: i32;
	var region2: ptr;
	var region2_size: i32;
	var sound_buffer = sound_output.sound_buffer;
	var error = sound_buffer.vtable.Lock(sound_buffer, 
		byte_lock_position, bytes_to_write, 
		&region1, &region1_size,
		&region2, &region2_size,
		0);
	var sample_count_1 = region1_size / sound_output.bytes_per_chunk;
	var sample_count_2 = region2_size / sound_output.bytes_per_chunk;
	
	if (error == DS_OK)
	{
		assert(sample_count_1 + sample_count_2 == game_sound_output.sample_count);
		var source_sample = game_sound_output.sample_out;
		var dest_sample = (i16*)region1;
		for (var i: i32 = 0; i < sample_count_1; ++i) {
			*dest_sample++ = *source_sample++;
			*dest_sample++ = *source_sample++;
		}
		dest_sample = (i16*)region2;
		for (var i: i32 = 0; i < sample_count_2; ++i) {
			*dest_sample++ = *source_sample++;
			*dest_sample++ = *source_sample++;
		}
		error = sound_output.sound_buffer.vtable.Unlock(sound_buffer,
			region1, region1_size, 
			region2, region2_size);
		assert(error == DS_OK);
		if (sample_count_2 > 0) {
			var last_sample = (i8*)((i32*)region2 + sample_count_2);
			sound_output.byte_last_written = (i32)(last_sample - sound_output.buffer_start);
		}
		elif (sample_count_1 > 0) {
			var last_sample = (i8*)((i32*)region1 + sample_count_1);
			sound_output.byte_last_written = (i32)(last_sample - sound_output.buffer_start);
		}
		if (sound_output.byte_last_written == sound_output.buffer_size) {
			sound_output.byte_last_written = 0;
		}
		assert(sound_output.byte_last_written >= 0 && sound_output.byte_last_written < sound_output.buffer_size);
	}
}

let win_create_backbuffer = fun (buffer: offscreen_buffer*; width: i32; height: i32) => void 
{
	let bytes_per_pixel = 4;
	buffer.width = width;
	buffer.height = height;
	buffer.info.header.biSize = 40;
	buffer.info.header.biWidth = width;
	buffer.info.header.biHeight = -height;
	buffer.info.header.biPlanes = 1;
	buffer.info.header.biBitCount = 32;
	buffer.info.header.biCompression = BI_RGB;
	var bitmap_size = bytes_per_pixel * width * height;
	if ((mm)buffer.memory != (mm)nullptr) {
		VirtualFree(buffer.memory, null, MEM_RELEASE);
	}
	buffer.memory = VirtualAlloc(nullptr, (mm)bitmap_size, MEM_COMMIT, PAGE_READWRITE);
	buffer.pitch = buffer.width * bytes_per_pixel;
}

let win_blit_to_screen = fun (buffer: offscreen_buffer*) => void 
{
    StretchDIBits(window.dc,
		0, 0, window.width, window.height,
		0, 0, buffer.width, buffer.height,
		buffer.memory, &buffer.info,
		DIB_RGB_COLORS, SRCCOPY
		);
}

let win_update_window_rect = fun () => void 
{
	var rect: RECT;
	GetClientRect(window.handle, &rect); 
	window.width = rect.right - rect.left;
	window.height = rect.bottom - rect.top;
}

let win_main_window_callback =
fun (window_handle: mm; message: i32; w_param: mm; l_param: mm) => mm 
{
	var result = null;
	if (message == WM_SIZE) {
		win_update_window_rect();	
	}
	elif (message == WM_CLOSE) {
		window_requests_quit = true;
	}
	elif (message == WM_DESTROY) {
		window_requests_quit = true;
	}
	elif (message == WM_PAINT) {
		var paint: PAINTSTRUCT;
		var context = BeginPaint(window_handle, &paint);
		win_blit_to_screen(&backbuffer);
		EndPaint(window_handle, &paint);
	} 
	else {
		result = DefWindowProcA(window_handle, message, w_param, l_param);
	} 
	return result;
}

let win_process_pending_messages = fun (game_input: game_input*) => void 
{
	var msg: MSG;
	while (PeekMessageA(&msg, null, 0, 0, PM_REMOVE) != 0) {
		var message = msg.message;
		if (message == WM_QUIT) {
			game_input.request_quit = true;
		} 
		elif (message == WM_SYSKEYDOWN
		 	|| message == WM_SYSKEYUP
		 	|| message == WM_KEYDOWN
		 	|| message == WM_KEYUP) {

			var w_param = (i32)(msg.wParam >> (mm)32);
			var l_param = (i32)(msg.lParam >> (mm)32);
			var vk_code = w_param;

			var was_down = (l_param & (1 << 30)) != 0;
			var is_down = (l_param & (1 << 31)) == 0;
			var key_up = was_down && !is_down;
			var key_down = !was_down && is_down; 

			if(vk_code == VK_ESCAPE) {
				game_input.request_quit = true;
			} elif (vk_code == VK_LEFT) {
				game_input.left_arrow.pressed = is_down;
				game_input.left_arrow.down = key_down;
				game_input.left_arrow.up = key_up;
			} elif (vk_code == VK_RIGHT) {
				game_input.right_arrow.pressed = is_down;
				game_input.right_arrow.down = key_down;
				game_input.right_arrow.up = key_up;
			} elif (vk_code == VK_UP) {
				game_input.up_arrow.pressed = is_down;
				game_input.up_arrow.down = key_down;
				game_input.up_arrow.up = key_up;

			} elif (vk_code == VK_DOWN) {
				game_input.down_arrow.pressed = is_down;
				game_input.down_arrow.down = key_down;
				game_input.down_arrow.up = key_up;
			} 
		} else {
			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}
	}
}

let win_update_next_sound_write_positon = fun 
(
	sound_output: sound_output*;
	perf_count_freq: i64;
) => void  
{
	var play_cursor: i32;
	var write_cursor: i32;
	var sound_buffer = sound_output.sound_buffer;
	var error = sound_buffer.vtable.GetCurrentPosition(sound_buffer, &play_cursor, &write_cursor);
	assert(error == DS_OK);

	if (play_cursor == write_cursor) {
		return;
	}

	// we haven't written anything yet
	if (!sound_output.first_write) {
		sound_output.byte_last_written = write_cursor;
		QueryPerformanceCounter(&sound_output.last_play_cursor_change_time);
	}

	if (play_cursor == sound_output.last_play_cursor) {
		var time: i64;
		QueryPerformanceCounter(&time);
		var cursor_dt = (f64)(time - sound_output.last_play_cursor_change_time) / (f64)perf_count_freq;
		var d_bytes = 4 * (i32)(cursor_dt * (f64)sound_output.samples_per_second);
		play_cursor += d_bytes;
		play_cursor = play_cursor % sound_output.buffer_size;
	} else {
		sound_output.last_play_cursor = play_cursor;
		QueryPerformanceCounter(&sound_output.last_play_cursor_change_time);
	}
	var position_to_write = sound_output.byte_last_written;
	if (play_cursor > write_cursor) {
		if (position_to_write > play_cursor || position_to_write < write_cursor) {
			position_to_write = write_cursor;
		}
	}
	if (play_cursor < write_cursor) {
		if (position_to_write > play_cursor && position_to_write < write_cursor) {
			position_to_write = write_cursor;
		}
	}
	var bytes_to_write = 0;
	var target_cursor = (play_cursor + sound_output.latency_byte_count) % sound_output.buffer_size;
	if (target_cursor > play_cursor) {
		if (position_to_write < target_cursor && position_to_write > play_cursor) {
			bytes_to_write = target_cursor - position_to_write;
		}
	}
	if (target_cursor < play_cursor) {
		if (position_to_write > play_cursor) {
			bytes_to_write = sound_output.buffer_size - position_to_write;
			bytes_to_write += target_cursor;
		}
		if (position_to_write < target_cursor) {
			bytes_to_write = target_cursor - position_to_write;
		}
	}
	 sound_output.next_write_positon = position_to_write;
	 sound_output.next_bytes_to_write = bytes_to_write;

	 if (!sound_output.first_write && bytes_to_write > 0) {
		 sound_output.first_write = true;
	 }

	// debug_print_i32("pc ", play_cursor, false);
	// debug_print_i32("ptw", position_to_write, false);
	// debug_print_i32("pos", sound_output.byte_last_written, false);
	// debug_print_i32("wc ", write_cursor, false);
	// debug_print_i32("tc ", target_cursor, false);
	// debug_print_i32("btw", bytes_to_write, false);
		
}

let main = fun () => void 
{
	var perf_count_freq: i64;
	QueryPerformanceFrequency(&perf_count_freq);
	

	win_create_backbuffer(&backbuffer, 1244, 705);

	var class_name  = cstr("PragmaScriptWindowClass\0");
	var window_name = cstr("handmade-pragmascript\0");
	var instance = GetModuleHandleA(null);
	var window_class: WNDCLASSEX;
	window_class.cbSize = 80;
	window_class.style = (CS_HREDRAW|CS_VREDRAW);
	window_class.lpfnWndProc = (ptr)win_main_window_callback;
	window_class.cbClsExtra = 0;
	window_class.cbWndExtra = 0;
	window_class.hInstance = instance;
	window_class.hIcon = null;
	window_class.hCursor = null;
	window_class.hbrBackground = null;
	window_class.lpszMenuName = nullptr;
	window_class.lpszClassName = class_name;
	window_class.hIconSm = null;
	RegisterClassExA(&window_class);
	
	window.handle = CreateWindowExA(
		0,
		class_name,
		window_name,
		WS_OVERLAPPEDWINDOW|WS_VISIBLE,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		null,
		null,
		instance,
		null
	);
	window.dc = GetDC(window.handle);
	win_update_window_rect();


	var sound_output: sound_output;
	sound_output.samples_per_second = 48000;
	sound_output.bytes_per_chunk = 2 * (i32)(sizeof(i16)); // 2 channels
	sound_output.buffer_size = sound_output.samples_per_second * sound_output.bytes_per_chunk * 1; // 1 seccond buffer
	sound_output.latency_byte_count = sound_output.buffer_size / 15; // 66ms latency
	var sound_buffer = win_init_direct_sound(window.handle, sound_output.buffer_size, sound_output.samples_per_second);
	sound_output.sound_buffer = sound_buffer;


	var game_sample_buffer = (i16*)VirtualAlloc(nullptr, (mm)sound_output.buffer_size, MEM_COMMIT, PAGE_READWRITE);
	assert((mm)game_sample_buffer != null);
	var base_address = nullptr;
	if (HANDMADE_INTERAL) {
		base_address = (ptr)terabytes(2);
	} else {
		base_address = nullptr;
	}
	var game_memory = game_memory {}; 
	game_memory.permanent_size = megabytes(1);
	game_memory.transient_size = 0;
	var total_size = game_memory.permanent_size + game_memory.transient_size;
	game_memory.permanent_data = VirtualAlloc(base_address, total_size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
	assert((mm)game_memory.permanent_data != null);
	game_memory.transient_data = (ptr)((mm)game_memory.permanent_data + (mm)game_memory.permanent_size);
	assert((mm)game_memory.transient_data != null);
	
	win_clear_sound_buffer(&sound_output);
	assert(sound_buffer.vtable.Play(sound_buffer, 0, 0, DSBPLAY_LOOPING) == DS_OK);
		
	var running = true;
	var frames = 0;
	var last_fps: f32 = 60;
	var current_counter: i64;
	var last_counter: i64;
	var last_counter_debug_stats: i64 = 0;
	QueryPerformanceCounter(&last_counter);

	var current_cycle_count: i64;
	var last_cycle_count = _rdtsc();
	var dt = 1.0 / 60.0;

	var write_cursor: i32;
	var play_cursor : i32;
	var error = sound_buffer.vtable.GetCurrentPosition(sound_buffer, &play_cursor, &write_cursor);
	assert(error == DS_OK);
	
	var game_start_time: i64;
	QueryPerformanceCounter(&game_start_time);

	var game_input: game_input;
	memset((i8*)(&game_input),0,sizeof(game_input));


	while (running) {
		win_process_pending_messages(&game_input);

		var game_render_target = game_render_target { };
		game_render_target.memory = backbuffer.memory;
		game_render_target.width = backbuffer.width;
		game_render_target.height = backbuffer.height;
		game_render_target.pitch = backbuffer.pitch;

		win_update_next_sound_write_positon(&sound_output, perf_count_freq);

		var game_sound_output = game_sound_output { };
		game_sound_output.sample_out = game_sample_buffer;
		game_sound_output.sample_count = sound_output.next_bytes_to_write / sound_output.bytes_per_chunk;
		game_sound_output.samples_per_second = sound_output.samples_per_second;
		
		game_output_sound(&game_memory, &game_sound_output);
		win_fill_sound_buffer(&sound_output, &game_sound_output);
		
		var game_time = game_time{};
		game_time.dt = dt;
		game_time.t = (f32)(last_counter - game_start_time) / (f32)perf_count_freq;
		game_input.time = game_time;
		game_input.request_quit |= window_requests_quit;

		running = game_update_and_render(&game_memory, &game_input, &game_render_target);
		if (!running) {
			win_clear_sound_buffer(&sound_output);
			sound_output.sound_buffer.vtable.Stop();
		}

		win_blit_to_screen(&backbuffer);
		++frames;

		current_cycle_count = _rdtsc();
		QueryPerformanceCounter(&current_counter);
		dt = (f32)((f64)(current_counter - last_counter) / (f64)perf_count_freq); 
		if (DEBUG_DRAW_FPS && (current_counter - last_counter_debug_stats > perf_count_freq))
		{
			last_counter_debug_stats = current_counter;
			
			var counter_elapsed = current_counter - last_counter;
			var cycles_elapsed = current_cycle_count - last_cycle_count;
			var frame_ms = 1000.0 * (f64)counter_elapsed / (f64)perf_count_freq;
			print_string("\n");
			print_f64(frame_ms);
			print_string("ms/f   ");
			print_f64(1000.0 / frame_ms);
			last_fps = 0.5 * last_fps + (f32)(0.5 * (1000.0 / frame_ms));
			print_string("fps   ");
			print_f64((f64)cycles_elapsed / 1000000.0);
			print_string("mcycles   ");
			debug_print_f32("dt", dt);
			frames = 0;
		}
		frames++;
		last_counter = current_counter;
		last_cycle_count = current_cycle_count;
	}
    ExitProcess(0);
}

