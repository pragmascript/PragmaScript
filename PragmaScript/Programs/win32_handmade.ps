let offscreen_buffer = struct
(
	info:   BITMAPINFO;
	memory: i8*;
	width:  i32;
	height: i32;
	pitch:  i32;
)
let window_info = struct 
(
	handle: umm;
	dc: umm;
	width: i32;
	height: i32;
)

var running = false;
var backbuffer = offscreen_buffer {};
var window = window_info {};

let bytes_per_pixel = 4;
let render_weird_gradient = fun (buffer: offscreen_buffer*; x_offset: i32; y_offset: i32; z_offset: i32) => void {
	var width = buffer.width;
	var height = buffer.height;
	var pitch = buffer.pitch;
	var row = (u8*)buffer.memory;
	for (var j = 0; j < height; ++j) {
		var pixel = (u32*)row;
		for (var i = 0; i < width; ++i) {
			var x = i + x_offset;
			var y = j + y_offset;
			var r = (u8)(x^y^z_offset);
			var g = (u8)y;
			var b = (u8)x;
			*pixel = ((u32)r << 16) | ((u32)g << 8) | (u32)b;
			pixel++;
		}
		row += pitch;
	}
}

let create_backbuffer = fun (buffer: offscreen_buffer*; width: i32; height: i32) => void {
	buffer.width = width;
	buffer.height = height;
	buffer.info.header.biSize = (u32)40;
	buffer.info.header.biWidth = width;
	buffer.info.header.biHeight = -height;
	buffer.info.header.biPlanes = (u16)1;
	buffer.info.header.biBitCount = (u16)32;
	buffer.info.header.biCompression = (u32)BI_RGB;
	var bitmap_size = bytes_per_pixel * width * height;
	if ((umm)buffer.memory != (umm)nullptr) {
		VirtualFree(buffer.memory, null, MEM_RELEASE);
	}
	buffer.memory = VirtualAlloc(nullptr, (umm)bitmap_size, MEM_COMMIT, PAGE_READWRITE);
	buffer.pitch = buffer.width * bytes_per_pixel;
}

let blit_to_screen = fun (buffer: offscreen_buffer*) => void {
    StretchDIBits(window.dc,
		0, 0, window.width, window.height,
		0, 0, buffer.width, buffer.height,
		buffer.memory, &buffer.info,
		DIB_RGB_COLORS, SRCCOPY
		);
}

let update_window_rect = fun () => void {
	var rect = RECT {};
	GetClientRect(window.handle, &rect); 
	window.width = rect.right - rect.left;
	window.height = rect.bottom - rect.top;
}

let main_window_callback =
fun (window_handle: umm; message: u32; w_param: umm; l_param: umm) => umm {
	var result = null;
	if (message == WM_SIZE) {
		update_window_rect();	
	}
	elif (message == WM_CLOSE) {
		running = false;
	}
	elif (message == WM_DESTROY) {
		running = false;
	}
	elif (message == WM_PAINT) {
		var paint = PAINTSTRUCT {};
		var context = BeginPaint(window_handle, &paint);
		var width = paint.rcPaint.right - paint.rcPaint.left;
		var height = paint.rcPaint.bottom - paint.rcPaint.top;
		// blit_to_screen(context, width, height);
		EndPaint(window_handle, &paint);
	} else {
		result = DefWindowProcA(window_handle, message, w_param, l_param);
	} 
	return result;
}

let main = fun () => void {
	create_backbuffer(&backbuffer, 1244, 705);

	var class_name = "PragmaScriptWindowClass\0";
	var window_name = "handmade-pragmascript\0";
	var instance = GetModuleHandleA(null);
	var window_class = WNDCLASSEX {};
	window_class.cbSize = (u32)80;
	window_class.style = (u32)(CS_HREDRAW|CS_VREDRAW);
	window_class.lpfnWndProc = (i8*)main_window_callback;
	window_class.cbClsExtra = 0;
	window_class.cbWndExtra = 0;
	window_class.hInstance = instance;
	window_class.hIcon = null;
	window_class.hCursor = null;
	window_class.hbrBackground = null;
	window_class.lpszMenuName = nullptr;
	window_class.lpszClassName = class_name.data;
	window_class.hIconSm = null;
	RegisterClassExA(&window_class);
	
	window.handle = CreateWindowExA(
		0,
		class_name.data,
		window_name.data,
		WS_OVERLAPPEDWINDOW|WS_VISIBLE,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		null,
		null,
		instance,
		null
	);
	window.dc = GetDC(window.handle);
	update_window_rect();

	running = true;
	var x_offset = 0;
	var y_offset = 0;
	var z_offset = 0;
	while (running) {
		var msg = MSG {};
		while (PeekMessageA(&msg, null, (u32)0, (u32)0, PM_REMOVE) != 0) {
			if (msg.message == WM_QUIT) {
				running = false;
			}
			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}
		
		render_weird_gradient(&backbuffer, x_offset, y_offset, z_offset);
		blit_to_screen(&backbuffer);

		x_offset += 1;
		y_offset += 2;
		z_offset += 1;
	}
    ExitProcess((u32)0);
}
