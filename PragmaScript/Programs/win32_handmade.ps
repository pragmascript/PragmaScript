var running = false;

var bitmap_info = BITMAPINFO { };
var bitmap_memory = nullptr;

var bitmap_width = 0;
var bitmap_height = 0;

let render_weird_gradient = fun (x_offset: i32, y_offset: i32) => void {
	var row = bitmap_memory;
	var pitch = width * 4;
	for (var y = 0; y < bitmap_height; ++y) {
		var pixel = (u8*)row;
		for (var x = 0; x < bitmap_width; ++x) {
			*pixel = (u8)(x + x_offset);
			++pixel;
			*pixel = (u8)(y + y_offset);
			++pixel;
			var weird = (u8)((x + x_offset)^(y + y_offset)); 
			*pixel = (u8)((x + x_offset)^(y + y_offset));
			++pixel;
			*pixel = (u8)(0);
			++pixel;
		}
		row += pitch;
	}
}

let resize_dib_section = fun (window: umm) => void {
	var rect = RECT {};
	GetClientRect(window, &rect); 
	var width = rect.right - rect.left;
	var height = rect.bottom - rect.top;
	bitmap_width = width;
	bitmap_height = height;

	bitmap_info.header.biSize = (u32)40;
	bitmap_info.header.biWidth = width;
	bitmap_info.header.biHeight = -height;
	bitmap_info.header.biPlanes = (u16)1;
	bitmap_info.header.biBitCount = (u16)32;
	bitmap_info.header.biCompression = (u32)BI_RGB;

	if ((umm)bitmap_memory != (umm)nullptr) {
		VirtualFree(bitmap_memory, null, MEM_RELEASE);
	}
	
	var bitmap_size = 4 * width * height;
	bitmap_memory = VirtualAlloc(nullptr, (umm)bitmap_size, MEM_COMMIT, PAGE_READWRITE);
}

let update_window = 
fun (device_context: umm, window_rect: RECT*, x: i32, y: i32, width: i32, height: i32) => void {

	// StretchDIBits(device_context,
	// 	x, y, width, height,
	// 	x, y, width, height,
	// 	bitmap_memory, &bitmap_info,
	// 	DIB_RGB_COLORS, SRCCOPY
	// 	);

	var window_width = window_rect.right - window_rect.left;
	var window_height = window_rect.bottom - window_rect.top;
    StretchDIBits(device_context,
		0, 0, bitmap_width, bitmap_height,
		0, 0, window_width, window_height,
		bitmap_memory, &bitmap_info,
		DIB_RGB_COLORS, SRCCOPY
		);
}

let main_window_callback =
fun (window: umm, message: u32, w_param: umm, l_param: umm) => umm {
	var result = null;
	if (message == WM_SIZE) {
		resize_dib_section(window);
	}
	elif (message == WM_CLOSE) {
		running = false;
	}
	elif (message == WM_DESTROY) {
		running = false;
	}
	elif (message == WM_PAINT) {
		var paint = PAINTSTRUCT {};
		var context = BeginPaint(window, &paint);
		var height = paint.rcPaint.bottom - paint.rcPaint.top;
		var width = paint.rcPaint.right - paint.rcPaint.left;
		var x = paint.rcPaint.left;
		var y = paint.rcPaint.top;

		update_window(context, &paint.rcPaint, x, y, width, height);

		EndPaint(window, &paint);
	} else {
		result = DefWindowProcA(window, message, w_param, l_param);
	} 
	return result;
}

let init_window = fun () => void {
	var class_name = "PragmaScriptWindowClass\0";
	var window_name = "handmade-pragmascript\0";
	
	var instance = GetModuleHandleA(null);
	var window_class = WNDCLASSEX {};
	window_class.cbSize = (u32)80;
	window_class.style = (u32)(CS_OWNDC|CS_HREDRAW|CS_VREDRAW);
	window_class.lpfnWndProc = (i8*)main_window_callback;
	window_class.cbClsExtra = 0;
	window_class.cbWndExtra = 0;
	window_class.hInstance = instance;
	window_class.hIcon = null;
	window_class.hCursor = null;
	window_class.hbrBackground = null;
	window_class.lpszMenuName = nullptr;
	window_class.lpszClassName = class_name.data;
	window_class.hIconSm = null;
	RegisterClassExA(&window_class);
	
	var window_handle = CreateWindowExA(
		0,
		class_name.data,
		window_name.data,
		WS_OVERLAPPEDWINDOW|WS_VISIBLE,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		null,
		null,
		instance,
		null
	);
}

let main = fun () => void {
	init_window();
	running = true;
	while (running) {
		var msg = MSG {};
		while (PeekMessageA(&msg, null, (u32)0, (u32)0, PM_REMOVE) != 0) {
			if (msg.message == WM_QUIT) {
				running = false;
			}
			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}
	}
    ExitProcess((u32)0);
}
