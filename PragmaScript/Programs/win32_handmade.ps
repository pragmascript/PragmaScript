let offscreen_buffer = struct
(
	info:   BITMAPINFO;
	memory: ptr;
	width:  i32;
	height: i32;
	pitch:  i32;
);
let window_info = struct 
(
	handle: umm;
	dc: umm;
	width: i32;
	height: i32;
);

var running = false;
var backbuffer: offscreen_buffer;
var window: window_info;
var x_offset = 0;
var y_offset = 0;
var z_offset = 0;


let init_direct_sound = fun (hwnd: umm; buffer_size: u32; samples_per_second: u32) => IDirectSoundBuffer* 
{
	var dsound_library = LoadLibraryA(cstr("dsound.dll\0"));
	assert((umm)dsound_library != null);

	var DirectSoundCreate: fun 
	(
		GuidDevice: ptr;
		ds: IDirectSound**;
		unused: ptr;
	) => i32;
	*((ptr*)(&DirectSoundCreate)) = (ptr)GetProcAddress(dsound_library, cstr("DirectSoundCreate\0"));
	assert((umm)DirectSoundCreate != null);

	var dsound_obj: IDirectSound*;
	assert(DirectSoundCreate(nullptr, &dsound_obj, nullptr) == DS_OK);
	
	assert(dsound_obj.vtable.SetCooperativeLevel(dsound_obj, hwnd, DSSCL_PRIORITY) == DS_OK);

	var desc_primary = DSBUFFERDESC { };
	desc_primary.flags = DSBCAPS_PRIMARYBUFFER;
	desc_primary.size = (u32)(sizeof(DSBUFFERDESC));
	desc_primary.bufferBytes = (u32)0;
	desc_primary.reserved = (u32)0;
	desc_primary.fxFormat = (WAVEFORMATEX*)nullptr;

	var primary_buffer: IDirectSoundBuffer*;
	assert(dsound_obj.vtable.CreateSoundBuffer(dsound_obj, &desc_primary, &primary_buffer, nullptr) == DS_OK);

	var wave_format = WAVEFORMATEX {};
	wave_format.formatTag = WAVE_FORMAT_PCM;
	wave_format.nChannels = (u16)2;
	wave_format.nBitsPerSample = (u16)16;
	wave_format.nSamplesPerSec = (u32)samples_per_second;
	wave_format.nBlockAlign = (wave_format.nChannels*wave_format.nBitsPerSample) / (u16)8;
	wave_format.nAvgBytesPerSec = wave_format.nSamplesPerSec * (u32)wave_format.nBlockAlign;
	wave_format.size = (u16)(sizeof(WAVEFORMATEX));
	assert(primary_buffer.vtable.SetFormat(primary_buffer, &wave_format) == DS_OK);

	var desc_secondary = DSBUFFERDESC { };
	desc_secondary.size = (u32)(sizeof(DSBUFFERDESC));
	desc_secondary.flags = (u32)0;
	desc_secondary.bufferBytes = (u32)buffer_size;
	desc_secondary.fxFormat = &wave_format;
	desc_secondary.reserved = (u32)0;

	var secondary_buffer: IDirectSoundBuffer*;
	assert(dsound_obj.vtable.CreateSoundBuffer(dsound_obj, &desc_secondary, &secondary_buffer, nullptr) == DS_OK);

	assert(secondary_buffer.vtable.Play(secondary_buffer, (u32)0, (u32)0, DSBPLAY_LOOPING) == DS_OK);

	return secondary_buffer;
}

let load_x_input = fun () => void 
{
	var x_input_lib = LoadLibraryA(cstr("xinput1_4.dll\0"));
	if (x_input_lib == null) {
		x_input_lib = LoadLibraryA(cstr("xinput1_3.dll\0"));
	}
	if (x_input_lib != null) {
		// var x = (ptr*)(&XInputGetState);
		*((ptr*)(&XInputGetState)) = (ptr)GetProcAddress(x_input_lib, cstr("XInputGetState\0"));
		assert((umm)XInputGetState != null);
	}
}

let handle_x_input = fun () => void 
{
	for(var c_idx = 0; c_idx < XUSER_MAX_COUNT; ++c_idx) {
		var x_state : XINPUT_STATE;
		var x_result = XInputGetState((u32)c_idx, &x_state); 
		if (x_result == XINPUT_SUCCESS)
		{
			// TODO: decode input
		}
		elif (x_result == XINPUT_DEVICE_NOT_CONNECTED)
		{
		}
	}
}

let bytes_per_pixel = 4;
let render_weird_gradient = fun (buffer: offscreen_buffer*; x_offset: i32; y_offset: i32; z_offset: i32) => void 
{
	var width  = buffer.width;
	var height = buffer.height;
	var pitch  = buffer.pitch;
	var row = (u8*)buffer.memory;
	for (var j = 0; j < height; ++j) {
		var pixel = (u32*)row;
		for (var i = 0; i < width; ++i) {
			var x = i + x_offset;
			var y = j + y_offset;
			var r = (u8)(x^y^z_offset);
			var g = (u8)y;
			var b = (u8)x;
			*pixel = ((u32)r << 16) | ((u32)g << 8) | (u32)b;
			pixel++;
		}
		row += pitch;
	}
}

let create_backbuffer = fun (buffer: offscreen_buffer*; width: i32; height: i32) => void 
{
	buffer.width = width;
	buffer.height = height;
	buffer.info.header.biSize = (u32)40;
	buffer.info.header.biWidth = width;
	buffer.info.header.biHeight = -height;
	buffer.info.header.biPlanes = (u16)1;
	buffer.info.header.biBitCount = (u16)32;
	buffer.info.header.biCompression = (u32)BI_RGB;
	var bitmap_size = bytes_per_pixel * width * height;
	if ((umm)buffer.memory != (umm)nullptr) {
		VirtualFree(buffer.memory, null, MEM_RELEASE);
	}
	buffer.memory = VirtualAlloc(nullptr, (umm)bitmap_size, MEM_COMMIT, PAGE_READWRITE);
	buffer.pitch = buffer.width * bytes_per_pixel;
}

let blit_to_screen = fun (buffer: offscreen_buffer*) => void 
{
    StretchDIBits(window.dc,
		0, 0, window.width, window.height,
		0, 0, buffer.width, buffer.height,
		buffer.memory, &buffer.info,
		DIB_RGB_COLORS, SRCCOPY
		);
}

let update_window_rect = fun () => void 
{
	var rect: RECT;
	GetClientRect(window.handle, &rect); 
	window.width = rect.right - rect.left;
	window.height = rect.bottom - rect.top;
}

let main_window_callback =
fun (window_handle: umm; message: u32; w_param: umm; l_param: umm) => umm 
{
	var result = null;
	if (message == WM_SIZE) {
		update_window_rect();	
	}
	elif (message == WM_CLOSE) {
		running = false;
	}
	elif (message == WM_DESTROY) {
		running = false;
	}
	elif (message == WM_PAINT) {
		var paint: PAINTSTRUCT;
		var context = BeginPaint(window_handle, &paint);
		blit_to_screen(&backbuffer);
		EndPaint(window_handle, &paint);
	} 
	elif (message == WM_SYSKEYDOWN 
		  || message == WM_SYSKEYUP
		  || message == WM_KEYDOWN
		  || message == WM_KEYUP) {

		var vk_code = (u32)w_param;
		var was_down = (l_param & (umm)(1 << 30)) != (umm)0;
		var is_down = (l_param & (umm)(1 << 31)) == (umm)0;
		var key_up = was_down && !is_down;
		var key_down = !was_down && is_down; 

		if(vk_code == VK_ESCAPE) {
			running = false;
		} elif (vk_code == VK_LEFT) {
			x_offset += 10;
		} elif (vk_code == VK_RIGHT) {
			x_offset -= 10;
		} elif (vk_code == VK_UP) {
			y_offset += 10;
		} elif (vk_code == VK_DOWN) {
			y_offset -= 10;
		} else {
			// if (key_down) {
			// 	print_string("key_down: ");
			// 	print_i32((i32)vk_code);
			// 	print_string("\n");
			// }
			// if (key_up) {
			// 	print_string("key_up: ");
			// 	print_i32((i32)vk_code);
			// 	print_string("\n");
			// }
		}
	}
	else {
		result = DefWindowProcA(window_handle, message, w_param, l_param);
	} 
	return result;
}

let main = fun () => void 
{
	load_x_input();
	create_backbuffer(&backbuffer, 1244, 705);

	var class_name  = cstr("PragmaScriptWindowClass\0");
	var window_name = cstr("handmade-pragmascript\0");
	var instance = GetModuleHandleA(null);
	var window_class: WNDCLASSEX;
	window_class.cbSize = (u32)80;
	window_class.style = (u32)(CS_HREDRAW|CS_VREDRAW);
	window_class.lpfnWndProc = (ptr)main_window_callback;
	window_class.cbClsExtra = 0;
	window_class.cbWndExtra = 0;
	window_class.hInstance = instance;
	window_class.hIcon = null;
	window_class.hCursor = null;
	window_class.hbrBackground = null;
	window_class.lpszMenuName = nullptr;
	window_class.lpszClassName = class_name;
	window_class.hIconSm = null;
	RegisterClassExA(&window_class);
	
	window.handle = CreateWindowExA(
		0,
		class_name,
		window_name,
		WS_OVERLAPPEDWINDOW|WS_VISIBLE,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		null,
		null,
		instance,
		null
	);
	window.dc = GetDC(window.handle);
	update_window_rect();

	let samples_per_second = (u32)48000;
	let n_channels = (u32)2;
	let byte_per_sample = (u32)2;
	let bytes_per_chunk = byte_per_sample * n_channels;
	let seconds = (u32)2;
	let buffer_size = (u32)samples_per_second * n_channels * byte_per_sample * seconds;
	let hz = (u32)256;
	let square_wave_half_period = samples_per_second / hz / (u32)2;
	var square_wave_counter = square_wave_half_period;
	var volume = (i16)1000;

	var sound_buffer = init_direct_sound(window.handle, buffer_size, samples_per_second);
	var write_cursor: u32;
	var play_cursor : u32;
	var sample_index = (u32)0;

	running = true;
	while (running) {
		var msg: MSG;
		while (PeekMessageA(&msg, null, (u32)0, (u32)0, PM_REMOVE) != 0) {
			if (msg.message == WM_QUIT) {
				running = false;
			}
			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}

		var write_cursor: u32;
		var play_cursor : u32;
		var error = sound_buffer.vtable.GetCurrentPosition(sound_buffer, &play_cursor, &write_cursor);
		assert(error == DS_OK);

		var byte_lock_position = (sample_index * bytes_per_chunk) % (u32)buffer_size;
		var bytes_to_write: u32;
		if (byte_lock_position > play_cursor) {
			bytes_to_write = buffer_size - byte_lock_position + play_cursor;
		} else {
			bytes_to_write = play_cursor - byte_lock_position;
		}
		var region1: ptr;
		var region1_size: u32;
		var region2: ptr;
		var region2_size: u32;

		error = sound_buffer.vtable.Lock(sound_buffer, 
			byte_lock_position, bytes_to_write, 
			&region1, &region1_size,
			&region2, &region2_size,
			(u32)0);
		if (error == DS_OK)
		{
			var sample = (i16*)region1;
			var sample_count = region1_size / bytes_per_chunk;
			for (var i = (u32)0; i < sample_count; ++i) {
				if (square_wave_counter == (u32)0) {
					square_wave_counter = square_wave_half_period;
					volume = -volume;
				}
				*sample++ = volume;
				*sample++ = volume;
				square_wave_counter--;
				sample_index++;
			}
			sample = (i16*)region2;
			sample_count = region2_size / bytes_per_chunk;
			for (var i = (u32)0; i < sample_count; ++i) {
				if (square_wave_counter == (u32)0) {
					square_wave_counter = square_wave_half_period;
					volume = -volume;
				}
				*sample++ = volume;
				*sample++ = volume;
				square_wave_counter--;
				sample_index++;
			}
			error = sound_buffer.vtable.Unlock(sound_buffer,
				region1, region1_size, 
				region2, region2_size);
			assert(error == DS_OK);
		}
		render_weird_gradient(&backbuffer, x_offset, y_offset, z_offset);
		blit_to_screen(&backbuffer);
		z_offset += 1;
	}
    ExitProcess((u32)0);
}

