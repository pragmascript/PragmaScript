var running = false;

var bitmap_info = BITMAPINFO { };
var bitmap_memory = nullptr;
var bitmap_handle = null;
var bitmap_device_context = null;

let resize_dib_section = fun (window: umm) => {
	var rect = RECT {};
	GetClientRect(window, &rect); 
	var width = rect.right - rect.left;
	var height = rect.bottom - rect.top;

	// TODO: free our DIBSection
	if (bitmap_handle != null)
	{
		DeleteObject(bitmap_handle);
	} else {
		bitmap_device_context = CreateCompatibleDC((umm)0); 	
	}
	 
	bitmap_info.header.biSize = (u32)40;
	bitmap_info.header.biWidth = width;
	bitmap_info.header.biHeight = height;
	bitmap_info.header.biPlanes = (u16)1;
	bitmap_info.header.biBitCount = (u16)32;
	bitmap_info.header.biCompression = (u32)BI_RGB;

	// NOTE: should get auto set to zero since its a global variable 
	// bitmap_info.header.biSizeImage = (u32)0;
	// bitmap_info.header.biXPelsPerMeter = 0;
	// bitmap_info.header.biYPelsPermeter = 0;
	// bitmap_info.header.biCrlUsed = (u32)0;
	// bitmap_info.header.biCrlImportant = (u32)0;
 
	var bitmap_handle = CreateDIBSection(
		bitmap_device_context, &bitmap_info,
		DIB_RGB_COLORS,
		&bitmap_memory,
		null,
		(u32)0
	);
}

let update_window = 
fun (context: umm, x: i32, y: i32, width: i32, height: i32) => {
	StretchDIBits(context,
		x, y, width, height,
		x, y, width, height,
		bitmap_memory, &bitmap_info,
		DIB_RGB_COLORS,
		(u32)0
		);
}

let main_window_callback =
fun (window: umm, message: u32, w_param: umm, l_param: umm) => umm {
	var result = null;
	if (message == WM_SIZE) {
		resize_dib_section(window);
	}
	elif (message == WM_CLOSE) {
		running = false;
	}
	elif (message == WM_DESTROY) {
		running = false;
	}
	elif (message == WM_PAINT) {
		
		var paint = PAINTSTRUCT {};
		var context = BeginPaint(window, &paint);
		var height = paint.rcPaint.bottom - paint.rcPaint.top;
		var width = paint.rcPaint.right - paint.rcPaint.left;
		var x = paint.rcPaint.left;
		var y = paint.rcPaint.top;

		update_window(context, x, y, width, height);

		EndPaint(window, &paint);
	} else {
		result = DefWindowProcA(window, message, w_param, l_param);
	} 
	return result;
}

let init_window = fun () => {
	var class_name = "PragmaScriptWindowClass\0";
	var window_name = "PragmaScript\0";
	
	var instance = GetModuleHandleA(null);
	var window_class = WNDCLASSEX {};
	window_class.cbSize = (u32)80;
	window_class.style = (u32)(CS_OWNDC|CS_HREDRAW|CS_VREDRAW);
	window_class.lpfnWndProc = (i8*)main_window_callback;
	window_class.cbClsExtra = 0;
	window_class.cbWndExtra = 0;
	window_class.hInstance = instance;
	window_class.hIcon = null;
	window_class.hCursor = null;
	window_class.hbrBackground = null;
	window_class.lpszMenuName = nullptr;
	window_class.lpszClassName = class_name.data;
	window_class.hIconSm = null;
	RegisterClassExA(&window_class);
	
	var window_handle = CreateWindowExA(
		0,
		class_name.data,
		window_name.data,
		WS_OVERLAPPEDWINDOW|WS_VISIBLE,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		null,
		null,
		instance,
		null
	);
}

let main = fun () => {
	init_window();
	running = true;
	while (running) {
		var message = MSG {};
		var message_result = GetMessageA(&message, null, (u32)0, (u32)0);
		if (message_result > 0) {
			TranslateMessage(&message);
			DispatchMessageA(&message);
		}
		else {
			break;
		}
	}
    ExitProcess((u32)0);
}

