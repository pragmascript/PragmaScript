import "windows.prag"

let null = (mm)0;
			  
let pi: f64 = 3.1415926535897932384626433832795028841971693993751058209749445923078164062;
let half_pi = pi / 2.0;
let pi_32 = (f32)pi;
let half_pi_32 = (f32)half_pi;

let _rdtsc = extern fun () => i64;
let __chkstk = extern fun () => void;

let print_string = fun (s: string) => void
{
 	WriteFile(console_output_handle, s.data, s.length, (i32*)nullptr, nullptr);
}

let print_error = fun (s: string) => void
{
	WriteFile(console_error_handle, s.data, s.length, (i32*)nullptr, nullptr);
}


["conditional":"debug"]
let assert = fun 
(
	value: bool; 
	msg: string = ""; 
	filepos: string = __file_pos__();
) => void 
{
	if (!value) {
		print_error("Assertion "); 
		if (msg.length > 0) 
		{
			print_error("\"");
			print_error(msg);
			print_error("\" ");
		}
		print_error("failed at: ");
		print_error(filepos);
		print_error("\n");
		*nullptr = 42;
	}
}


#if DEBUG
let cstr = fun(value: string; filepos: string = __file_pos__()) => i8* 
{
	assert(value[value.length - 1] == 0, "c-string not null terminated", filepos);
	return value.data;
}
#else
let cstr = fun(value: string) => i8* 
{
	return value.data;
}
#endif

// let __chkstk = fun() => void 
// {
// 	return;
// }
// https://raw.githubusercontent.com/Microsoft/compiler-rt/8902445ef0cb23430ab6d9e3213c02c23752196d/lib/builtins/x86_64/chkstk.S
// https://github.com/Microsoft/compiler-rt/blob/8902445ef0cb23430ab6d9e3213c02c23752196d/lib/builtins/i386/chkstk.S
// void __chkstk() 
// {
// 	 __asm__ ( "push   %rcx \t\n"
//                "push   %rax \t\n"
//                "cmp    $0x1000,%rax \t\n"
//                "lea    24(%rsp),%rcx \t\n"
//                "jb     1f \t\n"
//                "2: \t\n"
//                "sub    $0x1000,%rcx \t\n"              
//                "orl    $0,(%rcx) \t\n"
//                "sub    $0x1000,%rax \t\n"              
//                "cmp    $0x1000,%rax \t\n"              
//                "ja     2b \t\n"              
//                "1: \t\n"
//                "sub    %rax,%rcx \t\n"
//                "orl    $0,(%rcx) \t\n"
//                "pop    %rax \t\n"
//                "pop    %rcx \t\n"
//                "ret \t\n"
//     );
// }
// // https://git.musl-libc.org/cgit/musl/tree/src/math
// let fmodf = fun(x: f32; y: f32) => f32
// {
// 	var result = x / y;
// 	return 3.0;
// }
let remainder = fun(x: f32; y: f32) => f32
{
	return x - floor(x / y) * y;
}


// TODO make a fast version
let memset = fun
(
	dest : ptr;
	value: i32;
	count: mm;
) => ptr
{
	var data = dest;
	while (data != (dest + count)) {
		*data++ = (i8\)value;
	}
	return dest;
}

let sinf = fun(x: f32) => f32 
{
    let p = 0.225;
    let a = 16 * sqrt(p);
    let b = (1 - p) / sqrt(p);

    var y = x / (2 * pi_32);
    y = y - floor(y + 0.5);  // y in range -0.5..0.5
    y = a * y * (0.5 - abs(y));
    return y * (b + abs(y));
}

// http://forum.devmaster.net/t/fast-and-accurate-sine-cosine/9648/85
let cosf = fun(value: f32) => f32 
{
	var x = half_pi_32 - value;
    let p = 0.225;
    let a = 16 * sqrt(p);
    let b = (1 - p) / sqrt(p);

    var y = x / (2 * pi_32);
    y = y - floor(y + 0.5);  // y in range -0.5..0.5
    y = a * y * (0.5 - abs(y));
    return y * (b + abs(y));
}

let lerp = fun(a: f32; b: f32; t: f32) => f32
{
	return a + (b-a)*t;
}

let abs_i32 = fun (value: i32) => i32
{
  if (value >= 0) {
    return value;
  } else {
    return -value;
  }
}

let print_i32 = fun (value: i32; signed: bool = true) => void
{
	if (signed) {
		print_i64((i64)value, true);
	} else {
		print_i64((i64\)value, false);
	}
}

let print_i64 = fun (value: i64; signed: bool = true) => void
{
	var v = value;
	var pd = print_dest { };
	pd.buffer = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
	assert(pd.buffer.length == 64); 
	pd.pos = 0;
	if (signed && v < 0) {
		v = -v;
		out_char(&pd, 45);
	}
	u64_to_ascii(&pd, v);
	pd.buffer.length = pd.pos;
	print_string(pd.buffer);
}

let print_f32 = fun (value: f32; precision: i32 = 4) => void
{
	print_f64(((f64)value), precision);	
}

let print_dest = struct
(
	buffer: string;
	pos: i32;
);

let out_char = fun (dest: print_dest*; char: i8) => void
{
	dest.buffer[dest.pos++] = char;
} 

var decimal_digits = "0123456789";
let u64_to_ascii = fun (dest: print_dest*; value: i64) => void
{
	let base = 10;
	var v = value;

	var start = &dest.buffer[dest.pos];
	while (true) {
		var index = v % (i64)base;
		var digit = decimal_digits[(i32)index];
		out_char(dest, digit);
		v /=\ (i64)base;
		if (v == 0) {
			break;
		}
	}
	var end = &dest.buffer[dest.pos];
	
	while(start <\ end) {
		--end;
		var temp = *end;
		*end = *start;
		*start = temp;
		++start;
	}
}

let print_f64 = fun (value: f64; precision: i32 = 4) => void
{
	var v = value;
	var pd = print_dest { };
	pd.buffer = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
	assert(pd.buffer.length == 64); 
	pd.pos = 0;
	if (v < 0) {
		v = -v;
		out_char(&pd, 45);
	}
	var int_part = (i64)v;
	u64_to_ascii(&pd, int_part);
	v -= (f64)int_part;
	out_char(&pd, 46);

	var first_fraction_char = pd.pos;
	var last_non_zero = pd.pos;
	for (var i = 0; i < precision; ++i) {
		v *= 10.0;
		var int_part = (i32)v;
		v -= (f64)int_part;
		assert(int_part < 10);
		out_char(&pd, decimal_digits[int_part]);
		if (int_part != 0) {
			last_non_zero = pd.pos;
		} 
	}
	
	assert(pd.pos < pd.buffer.length);

	// if (first_fraction_char != last_non_zero) {
	// 	pd.buffer.length = last_non_zero;
	// } else {
	// 	pd.buffer.length = first_fraction_char - 1;
	// }
	pd.buffer.length = pd.pos;
	print_string(pd.buffer);
}


let debug_print_i64 = fun (name: string; value: i64; signed: bool = true) => void
{
	print_string(name);
	print_string(": ");
	print_i64(value, signed);
	print_string("\n");
}

let debug_print_i32 = fun (name: string; value: i32; signed: bool = true) => void
{
	print_string(name);
	print_string(": ");
	print_i32(value, signed);
	print_string("\n");
}
let debug_print_f32 = fun (name: string; value: f32; precision: i32 = 4) => void
{
	print_string(name);
	print_string(": ");
	print_f32(value, precision);
	print_string("\n");
}
let debug_print_f64 = fun (name: string; value: f64; precision: i32 = 4) => void
{
	print_string(name);
	print_string(": ");
	print_f64(value, precision);
	print_string("\n");
}

let __hack_reserve_intrinsics = fun () => bool
{
	if ((mm)memset == 1234 || (mm)__chkstk == 1234 || (mm)cosf == 1234 || (mm)sinf == 1234) {
		print_string("");
		return true;
	}
	return false;
}
var __intrinsics = __hack_reserve_intrinsics();