var console_output_handle = GetStdHandle(-11);
var console_input_handle = GetStdHandle(-10);
let print_string = fun (s: string) => void
{
 	WriteFile(console_output_handle, s.data, (u32)s.length, (u32*)nullptr, nullptr);
}

let WS_OVERLAPPEDWINDOW = 13565952;
let WS_VISIBLE    = 0x10000000; 
let CW_USEDEFAULT = 0x80000000;
let CS_OWNDC   = 0x0020;
let CS_HREDRAW = 0x0002;
let CS_VREDRAW = 0x0001;
let WM_PAINT = (u32)15;
let WM_CLOSE = (u32)16;
let WM_DESTROY = (u32)2;
let WM_SIZE = (u32)5;
let WM_QUIT = (u32)18;
let WM_SYSKEYDOWN = (u32)260;
let WM_SYSKEYUP = (u32)261;
let WM_KEYDOWN = (u32)256;
let WM_KEYUP = (u32)257;
let WHITENESS = (u32)16711778;
let BLACKNESS = (u32)66;
let SRCCOPY = (u32)13369376;
let DIB_RGB_COLORS = (u32)0;
let BI_RGB = (u32)0;
let MEM_COMMIT     = (u32)0x00001000;
let MEM_RESERVE    = (u32)0x00002000;
let MEM_RESET      = (u32)0x00008000;
let MEM_RESET_UNDO = (u32)0x10000000;
let PAGE_READWRITE = (u32)0x04;
let MEM_RELEASE = (u32)0x8000;
let PM_REMOVE = (u32)0x0001;

let VK_ESCAPE = (u32)0x1B;
let VK_UP     = (u32)0x26;
let VK_DOWN   = (u32)0x28;
let VK_LEFT   = (u32)0x25;
let VK_RIGHT  = (u32)0x27;
let VK_SPACE  = (u32)0x20;


let WNDCLASSEX = struct 
(
	cbSize: u32;
  style: u32;
  lpfnWndProc: u8*;
  cbClsExtra: i32;
  cbWndExtra: i32;
  hInstance: umm;
  hIcon: umm;
  hCursor: umm;
  hbrBackground: umm;
  lpszMenuName: u8*;
  lpszClassName: u8*;
	hIconSm: umm;
);
let POINT = struct 
(
	x: i32;
	y: i32;
);
let MSG = struct
(
	hwnd: umm;
	message: u32;
	wParam: umm;
	lParam: umm;
	time: i32;
	pt: POINT;
  pad: umm;
);
let RECT = struct 
(
	left: i32;
	top: i32;
	right: i32;
	bottom: i32;
);
let PAINTSTRUCT = struct
(
	hdc: umm;
	fErase: i32;
	rcPaint: RECT;
	fRestore: i32;
	fIncUpdate: i32;
	reserved0: umm;
	reserved1: umm;
	reserved2: umm;
	reserved3: umm;
);

let BITMAPINFOHEADER = struct
(
  biSize: u32;
  biWidth: i32;
  biHeight: i32;
  biPlanes: u16;
  biBitCount: u16;
  biCompression: u32;
  biSizeImage: u32;
  biXPelsPerMeter: i32;
  biYPelsPerMeter: i32;
  biClrUsed: u32;
  biClrImportant: u32;
);

let RGBQUAD = struct 
(
  blue: u8;
  green: u8;
  red: u8;
  reserved: u8;
);

let BITMAPINFO = struct
(
	header: BITMAPINFOHEADER;
	rgb: RGBQUAD;
);

let WriteFile = extern fun
(
  hFile: umm;
  lpBuffer: u8*;
  nNumberOfBytesToWrite: u32;
  lpNumberOfBytesWritten: u32*;
  lpOverlapped: ptr;
) => i32;

let ReadFile = extern fun
(
  hFile: umm;
  lpBuffer: ptr;
  nNumberOfBytesToRead: u32;
  nNumberOfBytesRead: u32*;
  lpOverlapped: ptr;
) => i32;

let GetStdHandle = extern fun (nStdHandle: i32) => umm;
let GetModuleHandleA = extern fun (lpModuleName: umm) => umm;
let RegisterClassExA = extern fun (window_class: WNDCLASSEX*) => u16;
let DefWindowProcA = extern fun (window: umm; message: u32; w_param: umm; l_param: umm) => umm;
let ExitProcess = extern fun(signal: u32) => void;
let CreateWindowExA = extern fun
(
   dwExStyle: i32;     
   lpClassName: u8*;
   lpWindowName: u8*;
   dwStyle: i32;
   x: i32;
   y: i32;
   nWidth: i32;
   nHeight: i32;
   hWndParent: umm;
   hMenu: umm;
   hInstance: umm;
   lpParam: umm;
) => umm;
let GetMessageA = extern fun
(
  message: MSG*;
  hWnd: umm;
  wMsgFilterMin: u32;
  wMsgFilterMax: u32;
) => i32;
let PeekMessageA = extern fun
(
  message: MSG*;
  hWnd: umm;
  wMsgFilterMin: u32;
  wMsgFilterMax: u32;
  wRemoveMsg: u32;
) => i32;

let TranslateMessage = extern fun (message: MSG*) => i32;
let DispatchMessageA = extern fun (message: MSG*) => umm;
let BeginPaint = extern fun (hwnd: umm; lpPaint: PAINTSTRUCT*) => umm;
let EndPaint = extern fun (hwnd: umm; lpPaint: PAINTSTRUCT*) => i32;
let PostQuitMessage = extern fun (nExitCode: i32) => void;
let GetClientRect = extern fun (hWnd: umm; rect: RECT*) => i32;
let CreateDIBSection = extern fun 
(
	hdc: umm;
	bitmap: BITMAPINFO*;
	iUsage: u32;
	ppvBits: ptr*;
	hSection: umm; 
	dwOffset: u32
) => umm;

let StretchDIBits = extern fun 
(
  hdc: umm;
  xDest: i32;
  yDest: i32;
  nDestWidth: i32;
  nDestHeight: i32;
  XSrc: i32;
  YSrc: i32;
  nSrcWidth: i32;
  nSrcHeight: i32;
  lpBits: ptr;
  lpBitsInfo: BITMAPINFO*;
  iUsage: u32;
  dwRop: u32;
) => i32;

// gdi32.lib
let PatBlt = extern fun 
(
	hdc: umm;
	nXLeft: i32;
	nYLeft: i32;
	nWidth: i32;
	nHeight: i32;
	dwRop: u32;
) => i32;

let DeleteObject = extern fun (obj: umm) => i32;
let CreateCompatibleDC = extern fun (hdc: umm) => umm;
let GetDC = extern fun (hWnd: umm) => umm;
let ReleaseDC = extern fun (hWnd: umm; hdc: umm) => i32;
let GetCompatibleDC = extern fun (hdc: umm) => umm;
let VirtualAlloc = extern fun 
(
  address: ptr;
  size: umm;
  allocation_type: u32;
  protect: u32;
) => ptr;
let VirtualFree = extern fun
(
  address: ptr;
  size: umm;
  free_type: u32;
) => i32;

let LoadLibraryA = extern fun(name: u8*) => umm;
let GetProcAddress = extern fun(lib: umm; name: u8*) => ptr;

let QueryPerformanceCounter = extern fun(result: u64*) => i32;
let QueryPerformanceFrequency = extern fun(result: u64*) => i32;

// ********************** XINPUT ********************** 

let XUSER_MAX_COUNT = 4;
let XINPUT_SUCCESS = (u32)0;
let XINPUT_DEVICE_NOT_CONNECTED = (u32)1167;
let XINPUT_GAMEPAD = struct
(
  Buttons: u16; 
  LeftTrigger: u8;
  RightTrigger: u8;
  ThumbLX: u16;
  ThumbLY: u16;
  ThumbRX: u16;
  ThumbRY: u16; // 12
);

let XINPUT_STATE = struct
(
  PacketNumber: u32;
  Gamepad: XINPUT_GAMEPAD;
);

let x_input_get_state = fun 
(
  dwUserIndex: u32;
  state : XINPUT_STATE*
) => u32;

var XInputGetState: fun 
(
  dwUserIndex: u32;
  state : XINPUT_STATE*
) => u32;


// ********************** DIRECTSOUND ********************** 

let DS_OK = 0;
let WAVE_FORMAT_PCM = (u16)1;
let DSBCAPS_PRIMARYBUFFER = (u32)1;
let DSBPLAY_LOOPING = (u32)1;
let DSSCL_PRIORITY = (u32)2;

let WAVEFORMATEX = struct
(
  formatTag: u16;
  nChannels: u16;
  nSamplesPerSec: u32;
  nAvgBytesPerSec: u32;
  nBlockAlign: u16;
  nBitsPerSample: u16;
  size: u16;
);

let DSBUFFERDESC = struct
(
  size: u32;
  flags: u32;
  bufferBytes: u32;
  reserved: u32;
  fxFormat: WAVEFORMATEX*;
); 

let IDirectSoundBuffer = struct
(
  vtable: DirectSoundBufferFunctions*;
);
let DirectSoundBufferFunctions = struct
(
  _unused0: ptr;
  _unused1: ptr;
  _unused2: ptr;

  _unused3: ptr; // GetCaps
  GetCurrentPosition: fun
  (
    this: IDirectSoundBuffer*;
    currentPlayCursor: u32*;
    currentWriteCursor: u32*;
  ) => i32;
  _unused4: ptr; // GetFormat
  _unused5: ptr; // GetVolume
  _unused6: ptr; // GetPan
  _unused7: ptr; // GetFrequency
  _unused8: ptr; // GetStatus
  _usused9: ptr; // Initialize
  Lock: fun
  (
    this: IDirectSoundBuffer*;
    writeCursor: u32;
    writeBytes: u32;
    audioRegion1: ptr*;
    audioRegion1Size: u32*;
    audioRegion2: ptr*;
    audioRegion2Size: u32*;
    flags: u32;
  ) => i32;
  Play: fun
  (
    this: IDirectSoundBuffer*;
    reserved: u32;
    priority: u32;
    flags: u32;
  ) => i32;
  _usused10: ptr; // SetCurrentPosition
  SetFormat: fun
  (
    this: IDirectSoundBuffer*;
    format: WAVEFORMATEX*;
  ) => i32;
  _usused11: ptr; // SetVolume
  _usused12: ptr; // SetPan
  _usused14: ptr; // SetFrequency
  _usused15: ptr; // Stop
  Unlock: fun
  (
    this: IDirectSoundBuffer*;
    audioRegion1: ptr;
    audioRegion1Size: u32;
    audioRegion2: ptr;
    audioRegion2Size: u32;
  ) => i32;
  _usused15: ptr;
);


let IDirectSound = struct
(
  vtable: DirectSoundFunctions*;
); 
let DirectSoundFunctions = struct
(
  _unused0: ptr;
  _unused1: ptr;
  _unused2: ptr;
  CreateSoundBuffer: fun
  (
    this: IDirectSound*;
    desc: DSBUFFERDESC*;
    dsb: IDirectSoundBuffer**;
    unused: ptr;
  ) => i32;
  _unused3: ptr; // GetCaps
  _unused4: ptr; // DuplicateSoundBuffer
  SetCooperativeLevel: fun
  (
    this: IDirectSound*;
    hwnd: umm;
    level: u32;
  ) => i32;
  _unused5: ptr; // Compact
  _unused6: ptr; // GetSpeakerConfig
  _unused7: ptr; // SetSpeakerConfig
  _unused8: ptr; // Initialize
);

