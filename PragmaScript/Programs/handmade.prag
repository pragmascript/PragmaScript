import "preamble.prag"
import "handmade_interface.prag"



let game_state = struct
(
    is_initialized: bool;
    x_offset: f32;
    y_offset: f32;
    volume: f32;
    target_volume: f32;
    tone_hz: f32;
    target_tone_hz: f32;
    phase_shift: f32;
    t_sine: f32;

    exit: bool;
    exit_start_time: f32;
    exit_start_volume: f32;
    exit_norm_time: f32;
);

["dll.export"]
let game_update_and_render: game_update_and_render =
{
    var result = true;
    var game_state = get_game_state(memory);
    handle_player_input(game_state, input);

    let exit_duration = 0.25;
    if (game_state.exit) {
        if (input.time.t - game_state.exit_start_time > exit_duration) {
            result = false;
            game_state.target_volume = 0.0;
        } else {
            var t = (input.time.t - game_state.exit_start_time) / exit_duration;
            game_state.exit_norm_time = t;
            game_state.target_volume = lerp(game_state.exit_start_volume, 0.0, t);
        }
    }
    render_weird_gradient(game_state, input, render_target);
    return result;
}

["dll.export"]
let game_output_sound: game_output_sound = 
{
    var game_state = get_game_state(game_memory);

    var wave_period = 2 * pi_32;
    var sample = sample_out;
    assert((ptr)sample != nullptr);

    var t_sine = game_state.t_sine;

    var phase_shift = 2*pi_32*t_sine * (game_state.tone_hz - game_state.target_tone_hz)
                      + game_state.phase_shift;
    game_state.tone_hz = game_state.target_tone_hz;

    
    var delta_t = 1.0 / (f32)samples_per_second;
    for (var i: i32 = 0; i < sample_count; ++i) {
        var t = (f32)i / (f32)(sample_count - 1);
        var v = lerp(game_state.volume, game_state.target_volume, t);
        var p = game_state.tone_hz * wave_period * t_sine;
         
        var x = (i16)(32767 * v * sinf(p + phase_shift));
        *sample++ = x;
        *sample++ = x;
        t_sine += delta_t;
    }
    game_state.t_sine = remainder(t_sine, wave_period);
    game_state.phase_shift = phase_shift;
    game_state.volume = game_state.target_volume;
}

let get_game_state = fun (memory: game_memory*) => game_state* 
{
    var game_state = (game_state*)memory.permanent_data;
    if (!game_state.is_initialized) {
        game_state.tone_hz = 128;
        game_state.target_tone_hz = 128;
        game_state.target_volume = 0.05;
        game_state.is_initialized = true;
    }
    return game_state;
}

let handle_player_input = fun 
(
    @game_state: game_state*;
    @game_input: game_input*; 
) => void 
{
    var dt = time.dt;
    if (request_quit && !exit) {
        exit = true;
        exit_start_time = time.t;
        exit_start_volume = volume;
    }
	if (left_arrow.pressed) {
		x_offset += dt * 150.0;
        target_volume -= dt * 0.02;
        if (target_volume < 0) {
            target_volume = 0;
        }
	}
	if (right_arrow.pressed) {
		x_offset -= dt * 150.0;
        target_volume += dt * 0.02;
	}
	if (up_arrow.pressed) {
		y_offset += dt * 150.0;
		// target_tone_hz += dt * 60.0;
	}
	if (down_arrow.pressed) {
		y_offset -= dt * 150.0;
		// target_tone_hz -= dt * 60;
		// if (target_tone_hz < 0) {
		// 	target_tone_hz = 0;
		// }
	}
    if (down_arrow.down) {
        target_tone_hz -= 25;
        if (target_tone_hz < 0) {
			target_tone_hz = 0;
		}
    }
    if (up_arrow.down) {
         target_tone_hz += 25;
    }

    consume_buttons(game_input);
}

let consume_buttons = fun
(
    @input: game_input*;
) => void
{
    consume_button(&up_arrow);
    consume_button(&down_arrow);
    consume_button(&left_arrow);
    consume_button(&right_arrow);
}

let consume_button = fun
(
    @button: game_keyboard_button*;
) => void
{
    down = false;
    up = false;
}

let render_weird_gradient = fun 
(
    game_state: game_state*; 
    input: game_input*;
    buffer: game_render_target*
) => void 
{
        
    var t = (i32)(input.time.t * 2);
    var dx = (i32)game_state.x_offset;
    var dy = (i32)game_state.y_offset;
	var width  = buffer.width;
	var height = buffer.height;
	var pitch  = buffer.pitch;
	var row = (i8*)buffer.memory;
	for (var j = 0; j < height; ++j) {
		var pixel = (i32*)row;
		for (var i = 0; i < width; ++i) {
			var x = i + dx;
			var y = j + dy;
			var r = (i8)(x^y^(1*t*t));
			var g = (i8)y; 
			var b = (i8)x;
            if (game_state.exit) {
                r = (i8)((f32\)r * (1.0-game_state.exit_norm_time));
                g = (i8)((f32\)g * (1.0-game_state.exit_norm_time));
                b = (i8)((f32\)b * (1.0-game_state.exit_norm_time));
            }
			*pixel = ((i32\)r << 16) | ((i32\)g << 8) | (i32\)b;
			pixel++;
		}
		row += pitch;
	}
}

[
"compile.entry",
"compile.dll"   : "true",
"compile.debug" : "true",
"compile.output": "handmade.dll",
"compile.opt"   : "0",
"compile.run"   : "false",
"compile.path"  : "C:\Program Files (x86)\Windows Kits\10\Lib\10.0.14393.0\um\x64",
"compile.libs"  : "kernel32.lib"
]
let main = fun () => void  
{
}