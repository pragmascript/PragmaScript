import "preamble.prag"
import "windows.prag"
import "win32_handmade.prag"


let game_sound_output = struct
(
    sample_out: i16*;
    sample_count: i32;
    samples_per_second: i32;
    sample_start_time: f32;
);

let game_keyboard_button = struct
(
    pressed: bool;
    down: bool;
    up: bool;
);

let game_time = struct
(
    dt: f32;
    t: f32;
);

let game_input = struct
(
    time: game_time; 
	up_arrow:    game_keyboard_button;
	left_arrow:  game_keyboard_button;
	right_arrow: game_keyboard_button;
	down_arrow:  game_keyboard_button;

    request_quit: bool;
);

let game_render_target = struct 
(
    memory: ptr;
	width:  i32;
	height: i32;
	pitch:  i32;
);


let game_memory = struct
(
    permanent_size: mm;
    permanent_data: ptr;

    transient_size: mm;
    transient_data: ptr;
);


// ******************

let game_state = struct
(
    is_initialized: bool;
    x_offset: f32;
    y_offset: f32;
    volume: f32;
    target_volume: f32;
    tone_hz: f32;
    target_tone_hz: f32;
    phase_shift: f32;
    t_sine: f32;

    exit: bool;
    exit_start_time: f32;
    exit_start_volume: f32;
    exit_norm_time: f32;
);

let game_update_and_render = fun
(
    memory: game_memory*;
    input: game_input*;
    render_target: game_render_target*;
) => bool
{
    var result = true;
    var game_state = get_game_state(memory);
    handle_player_input(game_state, input);

    let exit_duration = 0.25;
    if (game_state.exit) {
        if (input.time.t - game_state.exit_start_time > exit_duration) {
            result = false;
            game_state.target_volume = 0.0;
        } else {
            var t = (input.time.t - game_state.exit_start_time) / exit_duration;
            game_state.exit_norm_time = t;
            game_state.target_volume = lerp(game_state.exit_start_volume, 0.0, t);
        }
    }
    render_weird_gradient(game_state, render_target);
    return result;
}

let get_game_state = fun (memory: game_memory*) => game_state* 
{
    var game_state = (game_state*)memory.permanent_data;
    if (!game_state.is_initialized) {
        game_state.tone_hz = 128;
        game_state.target_tone_hz = 128;
        game_state.target_volume = 0.05;
        game_state.is_initialized = true;
    }
    return game_state;
}

let handle_player_input = fun 
(
    @game_state: game_state*;
    @game_input: game_input*; 
) => void 
{
    var dt = time.dt;
    if (request_quit && !exit) {
        exit = true;
        exit_start_time = time.t;
        exit_start_volume = volume;
    }
	if (left_arrow.pressed) {
		x_offset += dt * 150.0;
        target_volume -= dt * 0.02;
        if (target_volume < 0) {
            target_volume = 0;
        }
	}
	if (right_arrow.pressed) {
		x_offset -= dt * 150.0;
        target_volume += dt * 0.02;
	}
	if (up_arrow.pressed) {
		y_offset += dt * 150.0;
		// target_tone_hz += dt * 60.0;
	}
	if (down_arrow.pressed) {
		y_offset -= dt * 150.0;
		// target_tone_hz -= dt * 60;
		// if (target_tone_hz < 0) {
		// 	target_tone_hz = 0;
		// }
	}
    if (down_arrow.down) {
        target_tone_hz -= 100;
        if (target_tone_hz < 0) {
			target_tone_hz = 0;
		}
    }
    if (up_arrow.down) {
         target_tone_hz += 100;
    }

    consume_buttons(game_input);
}

let consume_buttons = fun
(
    @input: game_input*;
) => void
{
    consume_button(&up_arrow);
    consume_button(&down_arrow);
    consume_button(&left_arrow);
    consume_button(&right_arrow);
}

let consume_button = fun
(
    @button: game_keyboard_button*;
) => void
{
    down = false;
    up = false;
}

let game_output_sound = fun 
(
    game_memory: game_memory*; 
    @sound_output: game_sound_output*;
) => void 
{
    var game_state = get_game_state(game_memory);

    var wave_period = 2 * pi_32;
    var sample = sample_out;
    assert((ptr)sample != nullptr);

    var t_sine = game_state.t_sine;

    var phase_shift = 2*pi_32*t_sine * (game_state.tone_hz - game_state.target_tone_hz)
                      + game_state.phase_shift;
    game_state.tone_hz = game_state.target_tone_hz;

    
    var delta_t = 1.0 / (f32)samples_per_second;
    for (var i: i32 = 0; i < sample_count; ++i) {
        var t = (f32)i / (f32)(sample_count - 1);
        var v = lerp(game_state.volume, game_state.target_volume, t);
        var p = game_state.tone_hz * wave_period * t_sine;
         
        var x = (i16)(32767 * v * sinf(p + phase_shift));
        *sample++ = x;
        *sample++ = x;
        t_sine += delta_t;
    }
    game_state.t_sine = remainder(t_sine, wave_period);
    game_state.phase_shift = phase_shift;
    game_state.volume = game_state.target_volume;
}

let render_weird_gradient = fun 
(
    game_state: game_state*; 
    buffer: game_render_target*
) => void 
{
    var dx = (i32)game_state.x_offset;
    var dy = (i32)game_state.y_offset;
	var width  = buffer.width;
	var height = buffer.height;
	var pitch  = buffer.pitch;
	var row = (i8*)buffer.memory;
	for (var j = 0; j < height; ++j) {
		var pixel = (i32*)row;
		for (var i = 0; i < width; ++i) {
			var x = i + dx;
			var y = j + dy;
			var r = (i8\)(x^y^(x+y));
			var g = (i8\)y;
			var b = (i8\)x;
            if (game_state.exit) {
                r = (i8\)((f32\)r * (1.0-game_state.exit_norm_time));
                g = (i8\)((f32\)g * (1.0-game_state.exit_norm_time));
                b = (i8\)((f32\)b * (1.0-game_state.exit_norm_time));
            }
			*pixel = ((i32\)r << 16) | ((i32\)g << 8) | (i32\)b;
			pixel++;
		}
		row += pitch;
	}
}