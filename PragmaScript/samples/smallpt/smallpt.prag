import "..\preamble.prag"
import "..\windows.prag"

// https://www.shadertoy.com/view/Xdf3zB

let Vec = struct 
(
    x: f32;
    y: f32;
    z: f32;
);
let v3 = fun (x: f32; y: f32; z: f32) => Vec {
    var result = Vec { x, y, z};
    return result;
}
var vz = Vec {0.0, 0.0, 0.0};
let add = fun (a: Vec*; b: Vec*) => Vec {
    var result = Vec { a.x + b.x, a.y + b.y, a.z + b.z};
    return result;
}
let sub = fun (a: Vec*; b: Vec*) => Vec {
    var result = Vec { a.x - b.x, a.y - b.y, a.z - b.z};
    return result;
}
let scaled = fun (a: Vec*; s: f32) => Vec {
    var result = Vec { a.x * s, a.y * s, a.z * s};
    return result;
}
let hadamard = fun (a: Vec*; b: Vec*) => Vec {
    var result = Vec { a.x * b.x, a.y * b.y, a.z * b.z};
    return result;
}
let normalize = fun (@a: Vec*) => void {
    var scl = 1.0 / Math.sqrt(x*x + y*y + z*z);
    x *= scl;
    y *= scl;
    z *= scl;
}
let normalized = fun (v: Vec*) => Vec {
    var result = *v;
    normalize(&result);
    return result;
}
let length = fun(@a: Vec*) => f32 {
    return Math.sqrt(x*x + y*y + z*z);
}
let sqr_length = fun(@a: Vec*) => f32 {
    var result = x*x + y*y + z*z;
    return result;
}

let dot = fun (a: Vec*; b: Vec*) => f32 {
    var result = a.x*b.x + a.y*b.y + a.z*b.z;
    return result;
}
let cross = fun (a: Vec*; b: Vec*) => Vec {
    var result = Vec 
    { 
        a.y * b.z - a.z * b.y, 
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    };
    return result;
}
let get_orthogonal = fun (v: Vec*) => Vec {
    var c0 = Vec {1.0, 0.0, 0.0};
    var c1 = Vec {0.0, 1.0, 0.0};
    var result = cross(v, &c0);
    if (sqr_length(&result) < 0.0001) {
        result = cross(v, &c1);
    }
    return result;
}

let Ray = struct 
(
    origin: Vec;
    direction: Vec;
);

namespace ReflectionType
{
    let diffuse = 0;
    let mirror = 1;
    let glass = 2;
}

let Sphere = struct 
(
    radius: f32;
    pos: Vec;
    emission: Vec;
    color: Vec;
    reflection_type: i32;
);


let intersect_sphere_ray = fun (sphere: Sphere*; ray: Ray*; distance: f32*) => bool {
    var op = sub(&sphere.pos, &ray.origin);
    var b = dot(&op, &ray.direction);
    var det = b*b - dot(&op, &op) + sphere.radius * sphere.radius;

    if (det < 0.0) {
        return false;
    } else {
        det = Math.sqrt(det);
    }
    var eps = 0.02;
    var t = b - det;
    if (t > eps) {
        *distance = t;
        return true;
    } else {
        t = b + det;
        if (t > eps) {
            *distance = t;
            return true;
        } else {
            return false;
        }
    }
    return false;
}

let clamp_01 = fun (x: f32) => f32 {
    if (x < 0.0) {
        return 0.0;
    } elif (x > 1.0) {
        return 1.0;
    }
    return x;
}

let to_int = fun (x: f32) => i32 {
    var m = Math.pow(clamp_01(x), 1.0 / 2.2) * 255.0 + 0.5;
    return (i32)(Math.trunc(m));
}

let intersect = fun(ray: Ray*; t: f32*; obj: Sphere**) => bool {
    let max = 10000000000.0;
    *t = max;
    *obj = (Sphere*)nullptr;
    
    var d: f32;
    var s = spheres;
    for (var i = 0; i < sphere_count; ++i) {
        if (intersect_sphere_ray(s, ray, &d) && d < *t) {
            *t = d;
            *obj = s;
        }
        s++;
    }
    return *t != max;
}

let radiance = fun(ray: Ray*; depth: i32; random_state: Random.State*) => Vec {
    var t: f32;
    var id = 0;
    var obj: Sphere*;
    if (!intersect(ray, &t, &obj)) {
        return vz;
    }
    
    var color = obj.color;
    
    if (depth > 5) {
        var nax_refl = Math.max(color.x, Math.max(color.y, color.z));
        if (Random.rand_f32() > nax_refl) {
            return obj.emission;
        } else {
            color = scaled(&color, 1.0 / nax_refl);
        }
        return color;
        // return obj.emission;
    }
    
    var delta = scaled(&ray.direction, t);
    var x = add(&ray.origin, &delta);
    var n = sub(&x, &obj.pos);
    normalize(&n);

    // return n;

    var nl = n;
    if (dot(&n, &ray.direction) >= 0)  {
        nl = scaled(&n, -1);
    }

    if (obj.reflection_type == ReflectionType.diffuse) {
        var r1 = Random.rand_f32(0, Math.tau_32, random_state);
        var r2 = Random.rand_f32(0.0, 1.0, random_state);
        var r2s = Math.sqrt(r2);
        var w = nl;
        var u = get_orthogonal(&w);
        normalize(&u);
        var v = cross(&w, &u);
        
        // get random vec on hemisphere
        var d1 = scaled(&u, Math.cos(r1) * r2s);
        var d2 = scaled(&v, Math.sin(r1) * r2s);
        var d3 = scaled(&w, Math.sqrt(1 - r2));
        var d = add(&d1, &d2);
        d = add(&d, &d3);

        var result = obj.emission;
        var random_ray = Ray{x, d};
        var recursive = radiance(&random_ray, depth + 1, random_state);
        recursive = hadamard(&color, &recursive);
        result = add(&result, &recursive);
        return result;
    } elif (obj.reflection_type == ReflectionType.mirror) {
        var random_ray: Ray;
        random_ray.origin = x;
        var proj_normal = scaled(&n, 2*dot(&n, &ray.direction));
        random_ray.direction = sub(&ray.direction, &proj_normal);
        var recursive = radiance(&random_ray, depth + 1, random_state);
        recursive = hadamard(&color, &recursive);
        var result = add(&recursive, &obj.emission);
        return result;
    } elif (obj.reflection_type == ReflectionType.glass) {
        var refl_ray: Ray;
        refl_ray.origin = x;
        var proj_normal = scaled(&n, 2*dot(&n, &ray.direction));
        refl_ray.direction = sub(&ray.direction, &proj_normal);
        var nc = 1.0;
        var nt = 1.5;
        var nnt: f32;
        var into = dot(&n, &nl) > 0.0;
        if (into) {
            nnt = nc / nt;
        } else {
            nnt = nt / nc;   
        }
        var ddn = dot(&ray.direction, &nl);
        var cos2t = 1.0 - nnt * nnt * (1.0 - ddn * ddn);
        if (cos2t < 0) {
            var recursive = radiance(&refl_ray, depth + 1, random_state);
            recursive = hadamard(&color, &recursive);
            var result = add(&recursive, &obj.emission);
            return result;
        }
        var tdir = scaled(&ray.direction, nnt);
        var n_refr: Vec;
        if (into) {
            n_refr = n;
        } else {
            n_refr = scaled(&n, -1);
        }
        var n_scl = ddn * nnt + Math.sqrt(cos2t);
        n_refr = scaled(&n_refr, n_scl);
        tdir = sub(&tdir, &n_refr);
        normalize(&tdir);
        var a = nt - nc;
        var b = nt + nc;
        var R0 = a * a / (1.0 * b * b);
        var c: f32;
        if (into) {
            c = 1 + ddn;
        } else {
            c = 1 - dot(&tdir, &n);
        }
        var Re = R0 + (1 - R0) * c * c * c * c * c;
        var Tr = 1 - Re;
        var P = 0.25 + 0.5 * Re;
        var RP = Re / P;
        var TP = Tr / (1 - P);

        var result = obj.emission;
        if (depth > 2) {
            if (Random.rand_f32(0, 1.0, random_state) < P) {
                var recursive = radiance(&refl_ray, depth + 1, random_state);
                recursive = scaled(&recursive, RP);
                result = add(&result, &recursive);
                return hadamard(&result, &color);
            } else {
                var r = Ray{x, tdir};
                var recursive = radiance(&r, depth + 1, random_state);
                recursive = scaled(&recursive, TP);
                result = add(&result, &recursive);
                return hadamard(&result, &color);
            }
        } else {
            var recursive = radiance(&refl_ray, depth + 1, random_state);
            recursive = scaled(&recursive, Re);
            result = add(&result, &recursive);
            
            var r = Ray{x, tdir};
            recursive = radiance(&r, depth + 1, random_state);
            recursive = scaled(&recursive, Tr);
            result = add(&result, &recursive);
            return hadamard(&result, &color);
        }
    } else {
        return vz;
    }
    return vz;
}

let sphere_count = 9;
var spheres: Sphere*;

let create_spheres = fun() => void {
    spheres = (Sphere*)Windows.VirtualAlloc(nullptr, (mm)(size_of(Sphere) * (mm)sphere_count), Windows.MEM_COMMIT, Windows.PAGE_READWRITE);
    var s = spheres;
    
    // crashes the compiler
    // var s = Sphere { big, Vec { big + 1  , 40.8, 81.6 }, vz            , Vec {0.75, 0.25, 0.25} };

    let big = 10000.0;
    // 0
    s.radius   = big;
    s.pos      = v3(big + 1, 40.8, 81.6);
    s.emission = vz;
    s.color    = v3(0.75, 0.25, 0.25);
    s.reflection_type = ReflectionType.diffuse;
    s++;
    // 1
    s.radius   = big;
    s.pos      = v3(-big + 99, 40.8, 81.6);
    s.emission = vz;
    s.color    = v3(0.25, 0.25, 0.75);
    s.reflection_type = ReflectionType.diffuse;
    s++;
    // 2
    s.radius   = big;
    s.pos      = v3(50, 40.8, big);
    s.emission = vz;
    s.color    = v3(0.75, 0.75, 0.75);
    s.reflection_type = ReflectionType.diffuse;
    s++;
    // 3
    s.radius   = big;
    s.pos      = v3(50, 40.8, -big + 170);
    s.emission = vz;
    s.color    = vz;
    s.reflection_type = ReflectionType.diffuse;
    s++;
    // 4
    s.radius   = big;
    s.pos      = v3(50, big, 81.6);
    s.emission = vz;
    s.color    = v3(0.75, 0.75, 0.75);
    s.reflection_type = ReflectionType.diffuse;
    s++;
    // 5
    s.radius   = big;
    s.pos      = v3(50, -big + 81.6, 81.6);
    s.emission = vz;
    s.color    = v3(0.75, 0.75, 0.75);
    s.reflection_type = ReflectionType.diffuse;
    s++;
    // 6
    s.radius   = 16.5;
    s.pos      = v3(27, 16.5, 47);
    s.emission = vz;
    s.color    = v3(0.999, 0.999, 0.999);
    s.reflection_type = ReflectionType.mirror;
    s++;
    // 7
    s.radius   = 16.5;
    s.pos      = v3(73, 16.5, 78);
    s.emission = vz;
    s.color    = v3(0.999, 0.999, 0.999);
    s.reflection_type = ReflectionType.glass;
    s++;
    // 8
    s.radius   = 600;
    s.pos      = v3(50, 681.6 - 0.27, 81.6);
    s.emission = v3(12.0, 12.0, 12.0);
    s.color    = vz;
    s.reflection_type = ReflectionType.diffuse;
}

let platform_write_file = fun (name: string; data: ptr; size_in_bytes: i32) => bool
{
    var handle = Windows.CreateFileA(cstr(name), Windows.GENERIC_WRITE, 0, nullptr, Windows.CREATE_ALWAYS, 0, 0);
    if (handle == null) {
        Windows.CloseHandle(handle);
        return false;
    }
    var bytes_written: i32 = 0;
    var result = Windows.WriteFile(handle, data, size_in_bytes, &bytes_written, nullptr);
    if (result != 0) {
        Windows.CloseHandle(handle);
        assert(size_in_bytes == bytes_written);
        return true;
    } else {
        Windows.CloseHandle(handle);
        return false;
    }

    Windows.CloseHandle(handle);
    return false;
}


let Tile = struct 
(
    cam: Ray;
    cam_x: Vec;
    cam_y: Vec;
    width: i32;
    height: i32;

    sx: i32;
    sy: i32;
    samples: i32;
    start: Vec*;
    tile_size: i32;
);

let render_tile = fun (@tile: Tile*; random_state: Random.State*) => void {
    var p = start;    
    for (var y = 0; y < tile_size; ++y) {
        var pixels = p;
        for (var x = 0; x < tile_size; ++x) {
            var sample_radiance = vz;
            for (var s = 0; s < samples; ++s) {
                var r1 = Random.rand_f32(0, 2.0, random_state);
                var dx: f32;
                if (r1 < 1.0) {
                    dx = Math.sqrt(r1) - 1;
                } else {
                    dx = 1.0 - Math.sqrt(2 - r1);
                }
                var r2 = Random.rand_f32(0, 2.0, random_state);
                var dy: f32;
                if (r2 < 1.0) {
                    dy = Math.sqrt(r2) - 1;
                } else {
                    dy = 1.0 - Math.sqrt(2 - r2);
                }
                
                var px = ((f32)sx + (f32)x + 0.5*dx) / (f32)width;
                var py = ((f32)sy + (f32)y + 0.5*dy) / (f32)height;

                var scx = scaled(&cam_x, px - 0.5);
                var scy = scaled(&cam_y, py - 0.5);
                var d = cam.direction;
                d = add(&d, &scx);
                d = add(&d, &scy);
                normalize(&d);

                var rp = cam.origin;
                var push_d = scaled(&d, 140);
                rp = add(&rp, &push_d);
                var sample_ray = Ray{rp, d};
                
                var r = radiance(&sample_ray, 0, random_state);
                sample_radiance = add(&sample_radiance, &r);
            }
            var sr = scaled(&sample_radiance, 1.0 / (f32)samples);
           
            *pixels++ = sr;
        }
        p += width;
    }
}


let RenderJob = struct
(
    random_state: Random.State;
    thread_idx: i32;
    thread_count: i32;
    tiles: Tile[];
    completed: bool;
);

let do_render_job = fun (@job: RenderJob*) => i32 {
    Random.init_seed(thread_idx, &random_state);
    var idx = thread_idx;
    while (idx < tiles.length) {
        // print_string("thread ");
        // print_i32(thread_idx);
        // print_string(" start rendering tile #");
        // print_i32(idx);
        // print_string("\n");

        render_tile(&tiles[idx], &random_state);

        // print_string("thread ");
        // print_i32(thread_idx);
        // print_string(" finished rendering tile #");
        // print_i32(idx);
        // print_string("\n");
        idx += thread_count;
    }
    print_string("thread #");
    print_i32(thread_idx);
    print_string(" completed\n");
    completed = true;
}


[
	"compile.output": "smallpt.exe",
	"compile.entry" : "true",
 	"compile.opt"   : "3",
    "compile.asm"   : "false",
 	"compile.run"   : "false",
 	"compile.libs"  : "kernel32.lib, libopenlibm.a",
	"compile.path"  : "C:\Program Files (x86)\Windows Kits\10\Lib\10.0.14393.0\um\x64, lib"
]
let main = fun () => void 
{
    create_spheres();
    
    let thread_count = 8;
    let samples = 400;
    let tile_size = 32;
    let x_tiles = 4*8;
    let y_tiles = 4*6;
    let width  = x_tiles * tile_size;
    let height = y_tiles * tile_size;
    var pixel_data = (Vec*)Windows.VirtualAlloc(nullptr, size_of(Vec) * (mm)width * (mm)height, Windows.MEM_COMMIT, Windows.PAGE_READWRITE);

    var cam: Ray;
    cam.origin = v3(50,52,295.6);
    cam.direction = v3(0, -0.042612, -1);
    normalize(&cam.direction);

    let fov = 0.5135;
    var cam_x = v3((f32)width * fov / (f32)height, 0, 0);
    var cam_y = cross(&cam_x, &cam.direction);
    normalize(&cam_y);
    cam_y = scaled(&cam_y, fov);


    // create tiles
    var tile_count = x_tiles * y_tiles;
    var tiles: Tile[];
    tiles.data = (Tile*)Windows.VirtualAlloc(nullptr, size_of(Tile) * (mm)tile_count, Windows.MEM_COMMIT, Windows.PAGE_READWRITE);
    tiles.length = tile_count;
    var idx = 0;
    for (var j = 0; j < y_tiles; ++j) {
        for (var i = 0; i < x_tiles; ++i) {
            var t = &tiles[idx++];
            t.sx = tile_size * i;
            t.sy = tile_size * j;
            t.start = pixel_data + (t.sy * width + t.sx);
            t.tile_size = tile_size;
            t.width = width;
            t.height = height;
            t.cam = cam;
            t.cam_x = cam_x;
            t.cam_y = cam_y;
            t.samples = samples;
        }
    }

    // create jobs
    var jobs: RenderJob[];
    jobs.data = (RenderJob*)Windows.VirtualAlloc(nullptr, size_of(RenderJob) * (mm)thread_count, Windows.MEM_COMMIT, Windows.PAGE_READWRITE);
    jobs.length = thread_count;
    for (var i = 0; i < jobs.length; ++i) {
        var j: RenderJob;
        j.thread_idx = i;
        j.thread_count = thread_count;
        j.tiles = tiles;
        jobs[i] = j;
    }

    // create and run threads
    for (var i = 1; i < jobs.length; ++i) {
        var job = &jobs[i];
        var thread_id: mm;
        var thread_handle = Windows.CreateThread(nullptr, null, (Windows.ThreadProc)do_render_job, (ptr)job, 0, &thread_id);
    }
    do_render_job(&jobs[0]);
    jobs[0].completed = true;

    while (true) {
        var all_completed = true;
        for (var i = 0; i < jobs.length; ++i) {
            // TODO(pragma): volatile!
            if (!jobs[i].completed) {
                all_completed = false;
                break;
            }
        }
        if (all_completed) {
            break;
        }
        Windows.Sleep(10);
    }
    print_string("finished tracing.\n");
    

    // write image
    var pif_size = 3*size_of(i32) * (mm)width * (mm)height + 3*size_of(i32);
    var pif_data = (i32*)Windows.VirtualAlloc(nullptr, pif_size, Windows.MEM_COMMIT, Windows.PAGE_READWRITE);
    var pif = pif_data;
    var pixels = pixel_data;
    *pif++ = 3141592654;
    *pif++ = width;
    *pif++ = height;
    for (var y = 0; y < height; ++y) {
        for (var x = 0; x < width; ++x) {
            var v = *pixels;
            var r = to_int(v.x);
            var g = to_int(v.y);
            var b = to_int(v.z);
            *pif++ = r;
            *pif++ = g;
            *pif++ = b;
            pixels++;
        }
    }
    platform_write_file("image.pif\0", (ptr)pif_data, (i32)pif_size);
    
    Windows.ExitProcess(0);
}
