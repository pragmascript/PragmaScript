import "..\preamble.prag"
import "..\windows.prag"

// https://www.shadertoy.com/view/Xdf3zB

let Vec = struct 
(
    x: f32;
    y: f32;
    z: f32;
);
let v3 = fun (x: f32; y: f32; z: f32) => Vec {
    var result = Vec { x, y, z};
    return result;
}


var vz = Vec {0.0, 0.0, 0.0};



let add = fun (a: Vec*; b: Vec*) => Vec {
    var result = Vec { a.x + b.x, a.y + b.y, a.z + b.z};
    return result;
}
let sub = fun (a: Vec*; b: Vec*) => Vec {
    var result = Vec { a.x - b.x, a.y - b.y, a.z - b.z};
    return result;
}
let scaled = fun (a: Vec*; s: f32) => Vec {
    var result = Vec { a.x * s, a.y * s, a.z * s};
    return result;
}
let hadamard = fun (a: Vec*; b: Vec*) => Vec {
    var result = Vec { a.x * b.x, a.y * b.y, a.z * b.z};
    return result;
}
let normalize = fun (@a: Vec*) => void {
    var scl = 1.0 / Math.sqrt(x*x + y*y + z*z);
    x *= scl;
    y *= scl;
    z *= scl;
}
let normalized = fun (v: Vec*) => Vec {
    var result = *v;
    normalize(&result);
    return result;
}
let length = fun(@a: Vec*) => f32 {
    return Math.sqrt(x*x + y*y + z*z);
}
let sqr_length = fun(@a: Vec*) => f32 {
    return x*x + y*y + z*z;
}

let dot = fun (a: Vec*; b: Vec*) => f32 {
    var result = a.x*b.x + a.y*b.y + a.z*b.z;
    return result;
}
let cross = fun (a: Vec*; b: Vec*) => Vec {
    var result = Vec 
    { 
        a.y * b.z - a.z * b.y, 
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    };
    return result;
}
let get_orthogonal = fun (v: Vec*) => Vec {
    var c0 = Vec {0.0, 1.0, 0.0};
    var c1 = Vec {0.0, 0.0, 1.0};
    var result = cross(v, &c0);
    if (sqr_length(&result) < 0.0001) {
        result = cross(v, &c1);
    }
    return result;
}

let Ray = struct 
(
    origin: Vec;
    direction: Vec;
);

let Sphere = struct 
(
    radius: f32;
    pos: Vec;
    emission: Vec;
    color: Vec;
);


let intersect_sphere_ray = fun (sphere: Sphere*; ray: Ray*; distance: f32*) => bool {
    var op = sub(&sphere.pos, &ray.origin);
    var b = dot(&op, &ray.direction);
    var det = b*b - dot(&op, &op) + sphere.radius * sphere.radius;

    if (det < 0.0) {
        return false;
    } else {
        det = Math.sqrt(det);
    }
    var eps = 0.0001;
    var t = b - det;
    if (t > eps) {
        *distance = t;
        return true;
    } else {
        t = b + det;
        if (t > eps) {
            *distance = t;
            return true;
        } else {
            return false;
        }
    }
    assert(false);
    return false;
}

let clamp_01 = fun (x: f32) => f32 {
    if (x < 0.0) {
        return 0.0;
    } elif (x > 1.0) {
        return 1.0;
    }
    return x;
}

let to_int = fun (x: f32) => i32 {
    var m = Math.pow(clamp_01(x), 1.0 / 2.2) * 255.0 + 0.5;
    return (i32)(Math.trunc(m));
}

let intersect = fun(ray: Ray*; t: f32*; id: i32*; spheres: Sphere[]) => bool {
    let max = 10000000000.0;
    *t = max;
    *id = -1;
    var d: f32;
    for (var i = 0; i < spheres.length; ++i) {
        if (intersect_sphere_ray(&spheres[i], ray, &d)) {
            *t = d;
            *id = i;
        }
    }
    return *id != -1;
}

let radiance = fun(ray: Ray*; depth: i32; spheres: Sphere[]) => Vec {
    var t: f32;
    var id = 0;
    if (!intersect(ray, &t, &id, spheres)) {
        return vz;
    }
    var obj = spheres[id];
    if (depth > 5) {
        return obj.emission;
    }
    
    var delta = scaled(&ray.direction, t);
    var x = add(&ray.origin, &delta);
    var n = sub(&x, &obj.pos);
    normalize(&n);

    var nl = n;
    if (dot(&n, &ray.direction) >= 0)  {
        nl = scaled(&n, -1);
    }
    var color = obj.color;
    var r1 = Random.rand_f32(0, Math.tau_32);
    var r2 = Random.rand_f32();
    var r2s = Math.sqrt(r2);
    var w = nl;
    var u = get_orthogonal(&w);
    normalize(&u);
    var v = cross(&w, &u);
    
    // get random vec on hemisphere
    var d1 = scaled(&u, Math.cos(r1) * r2s);
    var d2 = scaled(&v, Math.sin(r1) * r2s);
    var d3 = scaled(&w, Math.sqrt(1 - r2));
    var d = add(&d1, &d2);
    d = add(&d, &d3);

    var result = obj.emission;
    var random_ray = Ray{x, d};
    var recursive = radiance(&random_ray, depth + 1, spheres);
    recursive = hadamard(&color, &recursive);
    result = add(&result, &recursive);

    return result;
}


let create_spheres = fun() => Sphere[] {
    var spheres: Sphere[];
    spheres.data = (Sphere*)Windows.VirtualAlloc(nullptr, (mm)(size_of(Sphere) * 9), Windows.MEM_COMMIT, Windows.PAGE_READWRITE);
    spheres.length = 9;
    var s: Sphere* = spheres.data;
    
    // crashes the compiler
    // var s = Sphere { big, Vec { big + 1  , 40.8, 81.6 }, vz            , Vec {0.75, 0.25, 0.25} };

    let big = 100000.0;
    // 0
    s.radius   = big;
    s.pos      = v3(big + 1, 40.8, 81.6);
    s.emission = vz;
    s.color    = v3(0.75, 0.25, 0.25);
    s++;
    // 1
    s.radius   = big;
    s.pos      = v3(-big + 99, 40.8, 81.6);
    s.emission = vz;
    s.color    = v3(0.25, 0.25, 0.75);
    s++;
    // 2
    s.radius   = big;
    s.pos      = v3(50, 40.8, big);
    s.emission = vz;
    s.color    = v3(0.75, 0.75, 0.75);
    s++;
    // 3
    s.radius   = big;
    s.pos      = v3(50, 40.8, -big + 170);
    s.emission = vz;
    s.color    = vz;
    s++;
    // 4
    s.radius   = big;
    s.pos      = v3(50, big, 81.6);
    s.emission = vz;
    s.color    = v3(0.75, 0.75, 0.75);
    s++;
    // 5
    s.radius   = big;
    s.pos      = v3(50, -big + 81.6, 81.6);
    s.emission = vz;
    s.color    = v3(0.75, 0.75, 0.75);
    s++;
    // 6
    s.radius   = big;
    s.pos      = v3(27, 16.5, 47);
    s.emission = vz;
    s.color    = v3(0.99, 0.99, 0.99);
    s++;
    // 7
    s.radius   = big;
    s.pos      = v3(73, 16.5, 78);
    s.emission = vz;
    s.color    = v3(0.99, 0.25, 0.25);
    s++;
    // 8
    s.radius   = 600;
    s.pos      = v3(50, 681.6 - 0.27, 81.6);
    s.emission = v3(12.0, 12.0, 12.0);
    s.color    = vz;

    return spheres;
}

[
	"compile.output": "smallpt.exe",
	"compile.entry" : "true",
	"compile.debug" : "true",
 	"compile.opt"   : "0",
 	"compile.run"   : "true",
 	"compile.libs"  : "kernel32.lib, libopenlibm.lib",
	"compile.path"  : "C:\Program Files (x86)\Windows Kits\10\Lib\10.0.14393.0\um\x64, lib"
]
let main = fun () => void 
{
    var spheres = create_spheres();
    
    var width  = 1024;
    var height = 768;
    var samples = 5000 / 4;

    var cam: Ray;
    cam.origin = v3(50,52,295.6);
    cam.direction = v3(0, -0.042612, -1);
    normalize(&cam.direction);
    


    Windows.ExitProcess(0);
}
