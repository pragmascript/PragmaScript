import "windows.prag"


let kilobytes = fun (bytes: mm) => mm 
{
	return bytes * 1024 ;
}
let megabytes = fun (bytes: mm) => mm 
{
	return bytes * 1024 * 1024;
}
let gigabytes = fun (bytes: mm) => mm
{
	return bytes * 1024 * 1024 * 1024;
}
let terabytes = fun (bytes: mm) => mm
{
	return bytes * 1024 * 1024 * 1024 * 1024;
}

let null = (mm)0;
let nullptr = (ptr)0;

["stub"]
let _rdtsc = extern fun () => i64;

["stub"]
let __chkstk = extern fun () => void;

let print_string = fun (s: string) => void
{
	assert(Windows.console_output_handle != Windows.INVALID_HANDLE_VALUE);
	Windows.WriteFile(Windows.console_output_handle, s.data, s.length, (i32*)nullptr, nullptr);
}
let print_error = fun (s: string) => void
{
	assert(Windows.console_error_handle != Windows.INVALID_HANDLE_VALUE);
	Windows.WriteFile(Windows.console_error_handle, s.data, s.length, (i32*)nullptr, nullptr);
}
["conditional":"debug"]
let assert = fun 
(
	value: bool; 
	msg: string = ""; 
	filepos: string = __file_pos__();
) => void 
{
	if (!value) {
		print_error("Assertion "); 
		if (msg.length > 0) 
		{
			print_error("\"");
			print_error(msg);
			print_error("\" ");
		}
		print_error("failed at: ");
		print_error(filepos);
		print_error("\n");
		*nullptr = 42;
	}
}


#if DEBUG
let cstr = fun(value: string; filepos: string = __file_pos__()) => i8* 
{
	assert(value[value.length - 1] == 0, "c-string not null terminated", filepos);
	return value.data;
}
#else
let cstr = fun(value: string) => i8* 
{
	return value.data;
}
#endif

let ord = fun(value: string) => i32
{
	assert(value.length == 1);
	return (i32)value[0];
}

// let __chkstk = fun() => void 
// {
// 	return;
// }
// https://raw.githubusercontent.com/Microsoft/compiler-rt/8902445ef0cb23430ab6d9e3213c02c23752196d/lib/builtins/x86_64/chkstk.S
// https://github.com/Microsoft/compiler-rt/blob/8902445ef0cb23430ab6d9e3213c02c23752196d/lib/builtins/i386/chkstk.S
// void __chkstk() 
// {
// 	 __asm__ ( "push   %rcx \t\n"
//                "push   %rax \t\n"
//                "cmp    $0x1000,%rax \t\n"
//                "lea    24(%rsp),%rcx \t\n"
//                "jb     1f \t\n"
//                "2: \t\n"
//                "sub    $0x1000,%rcx \t\n"              
//                "orl    $0,(%rcx) \t\n"
//                "sub    $0x1000,%rax \t\n"              
//                "cmp    $0x1000,%rax \t\n"              
//                "ja     2b \t\n"              
//                "1: \t\n"
//                "sub    %rax,%rcx \t\n"
//                "orl    $0,(%rcx) \t\n"
//                "pop    %rax \t\n"
//                "pop    %rcx \t\n"
//                "ret \t\n"
//     );
// }
// // https://git.musl-libc.org/cgit/musl/tree/src/math
// let fmodf = fun(x: f32; y: f32) => f32
// {
// 	var result = x / y;
// 	return 3.0;
// }


// TODO make a fast version
let memset = fun
(
	dest : ptr;
	value: i32;
	count: mm;
) => ptr
{
	var data = dest;
	while (data != (dest + count)) {
		*data++ = (i8\)value;
	}
	return dest;
}

let print_i32 = fun (value: i32; signed: bool = true) => void
{
	if (signed) {
		print_i64((i64)value, true);
	} else {
		print_i64((i64\)value, false);
	}
}

let print_i64 = fun (value: i64; signed: bool = true) => void
{
	var v = value;
	var pd: print_dest;
	pd.pos = 0;
	pd.buffer = "                                                                ";
	assert(pd.buffer.length == 64); 
	
	if (signed && v < 0) {
		v = -v;
		out_char(&pd, 45);
	}
	u64_to_ascii(&pd, v);
	pd.buffer.length = pd.pos;
	print_string(pd.buffer);
}

let print_f32 = fun (value: f32; precision: i32 = 4) => void
{
	print_f64((f64)value, precision);	
}

let print_dest = struct
(
	buffer: string;
	pos: i32;
);

let out_char = fun (dest: print_dest*; char: i8) => void
{
	assert(dest.pos >= 0 && dest.pos < dest.buffer.length);
	dest.buffer[dest.pos++] = char;
} 

var decimal_digits = "0123456789";
let u64_to_ascii = fun (dest: print_dest*; value: i64) => void
{
	let base = 10;
	var v = value;

	var start = &dest.buffer[dest.pos];
	while (true) {
		var index = (i32)(v % (i64)base);
		assert(index >= 0 && index < 10);
		var digit = decimal_digits[index];
		out_char(dest, digit);
		v /=\ (i64)base;
		if (v == 0) {
			break;
		}
	}
	var end = &dest.buffer[dest.pos];

	while(start <\ end) {
		--end;
		var temp = *end;
		*end = *start;
		*start = temp;
		++start;
	}
}
let print_f64 = fun (value: f64; precision: i32 = 4) => void
{
	var v = value;
	var pd: print_dest;
	pd.pos = 0;
	pd.buffer = "                                                                ";
	assert(pd.buffer.length == 64); 

	if (v < 0) {
		v = -v;
		out_char(&pd, 45);
	}
	var int_part = (i64\)v;
	u64_to_ascii(&pd, int_part);
	v -= (f64)int_part;
	out_char(&pd, 46);

	var first_fraction_char = pd.pos;
	var last_non_zero = pd.pos;
	for (var i = 0; i < precision; ++i) {
		v *= 10.0;
		var int_part = (i32)v;
		v -= (f64)int_part;
		assert(int_part < 10 && int_part >= 0);
		out_char(&pd, decimal_digits[int_part]);
		if (int_part != 0) {
			last_non_zero = pd.pos;
		} 
	}
	assert(pd.pos <= pd.buffer.length);
	pd.buffer.length = pd.pos;
	print_string(pd.buffer);
}

let debug_print_i64 = fun (name: string; value: i64; signed: bool = true) => void
{
	print_string(name);
	print_string(": ");
	print_i64(value, signed);
	print_string("\n");
}
let debug_print_i32 = fun (name: string; value: i32; signed: bool = true) => void
{
	print_string(name);
	print_string(": ");
	print_i32(value, signed);
	print_string("\n");
}
let debug_print_f32 = fun (name: string; value: f32; precision: i32 = 4) => void
{
	print_string(name);
	print_string(": ");
	print_f32(value, precision);
	print_string("\n");
}
let debug_print_f64 = fun (name: string; value: f64; precision: i32 = 4) => void
{
	print_string(name);
	print_string(": ");
	print_f64(value, precision);
	print_string("\n");
}

let debug_print_bool = fun (name: string; value: bool) => void
{
	print_string(name);
	print_string(": ");
	if (value) {
		print_string("true");
	} else {
		print_string("false");
	}
	print_string("\n");
}


namespace Random 
{
	let seed = 12345;
	let State = struct 
	(
		z1: i32;
		z2: i32;
		z3: i32;
		z4: i32; 	
	);
	var state: State = State{seed, seed, seed, seed};

	var z1: i32 = seed;
	var z2: i32 = seed;
	var z3: i32 = seed;
	var z4: i32 = seed;

	let init_seed = fun (seed: i32; state: State* = &state) => void {
		state.z1 = seed;
		state.z2 = seed;
		state.z3 = seed;
		state.z4 = seed;
	}

	// http://www.iro.umontreal.ca/~simardr/rng/lfsr113.c
	let rand_i32 = fun (state: State* = &state) => i32 {
		var b: i32;
		b  = ((z1 << 6) ^ z1) >>\ 13;
		z1 = ((z1 & 4294967294) << 18) ^ b;
		b  = ((z2 << 2) ^ z2) >>\ 27;
		z2 = ((z2 & 4294967288) << 2) ^ b;
		b  = ((z3 << 13) ^ z3) >>\ 21;
		z3 = ((z3 & 4294967280) << 7) ^ b;
		b  = ((z4 << 3) ^ z4) >>\ 12;
		z4 = ((z4 & 4294967168) << 13) ^ b;
   		return (z1 ^ z2 ^ z3 ^ z4);
	}
	let rand_f32 = fun (min: f32 = 0.0; max: f32 = 1.0; state: State* = &state;) => f32 {
		var x = rand_i32();
		var result = (f32\)x / 4294967295.0;
		result = min + result * (max - min);
		return result;
	}
	let rand_xkcd = fun () => i32 {
		return 4;  // chosen by fair dice roll.
		           // guaranteed to be random.
	}
}



let __hack_reserve_intrinsics = fun () => bool
{
	if ((mm)memset == 1234 || (mm)__chkstk == 1234) {
		print_string("");
		return true;
	}
	return false;
}
var __intrinsics = __hack_reserve_intrinsics();