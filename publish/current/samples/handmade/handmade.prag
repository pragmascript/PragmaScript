import "../preamble.prag"
import "..\math.prag"
import "handmade_interface.prag"
import "handmade_math.prag"


namespace Handmade.Game
{
    let game_state = struct
    (
        is_initialized: bool;

        exit: bool;

        player_x: f32;
        player_y: f32;
        new_player_x: f32;
        new_player_y: f32;
    );


    ["dll.export"]
    let game_update_and_render = fun
    (
        memory: game_memory*;
        input: game_input*;
        render_target: game_render_target*;
    ) => bool
    {
        var result = true;
        var game_state = get_game_state(memory);
        handle_player_input(game_state, input);

        if (game_state.exit) {
            result = false;
        }
        
        

        var background_color = color { 0.25, 0.35, 0.45, 1.0 };
        // animate_background_color(&background_color, input.time.t);
        draw_rectangle(render_target, min_max_rect(0, 0, render_target.width, render_target.height), background_color);
        
        var tile_map = 
        [
            [1, 1, 1, 1,  1, 1, 1, 1,  0, 1, 1, 1,  1, 1, 1, 1],
            [1, 1, 0, 0,  0, 1, 0, 0,  0, 0, 0, 0,  0, 0, 1, 1],
            [1, 1, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 0, 1],
            [1, 0, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 0, 1],
            [0, 0, 0, 0,  0, 1, 0, 0,  1, 0, 0, 0,  0, 0, 0, 0],
            [1, 1, 0, 0,  0, 1, 0, 0,  1, 0, 0, 0,  0, 1, 0, 1],
            [1, 0, 0, 0,  0, 1, 0, 0,  1, 0, 0, 0,  1, 0, 0, 1],
            [1, 1, 1, 1,  1, 0, 0, 0,  0, 0, 0, 0,  0, 1, 0, 1],
            [1, 1, 1, 1,  1, 1, 1, 1,  0, 1, 1, 1,  1, 1, 1, 1]
        ];
        assert(len(tile_map, 0) == 9);
        assert(len(tile_map, 1) == 16);
        let tile_size = 72;
        let offset = tile_size / 2;
        
        for (var y = 0; y < len(tile_map, 0); ++y) {
            for (var x = 0; x < len(tile_map, 1); ++x) {
                var tile_id = tile_map[y, x];

                var color = color {};
                var red = color {1.0, 0.0, 0.0, 1.0};
                // var green = color {0.0, 1.0, 0.0, 1.0};
                
                if (tile_id == 0) {
                    color = background_color;
                } elif (tile_id == 1) {
                    color = red;
                }
                var pos_x = offset + x * tile_size;
                var pos_y = offset + y * tile_size;
                
                draw_rectangle(render_target, center_half_size_rect(pos_x, pos_y, tile_size/2), color);
            }
        }

        var player_tile_x = Math.round_to_i32((game_state.new_player_x - (f32)offset) / (f32)tile_size);
        var player_tile_y = Math.round_to_i32((game_state.new_player_y - (f32)offset) / (f32)tile_size);

        if (player_tile_x >= 0 && player_tile_x < len(tile_map, 1) && 
            player_tile_y >= 0 && player_tile_y < len(tile_map, 0)) {
            var tile_value = tile_map[player_tile_y, player_tile_x];
            if (tile_value == 0) {
                game_state.player_x = game_state.new_player_x;
                game_state.player_y = game_state.new_player_y;
            }
        }
                
        var pos_x = offset + player_tile_x * tile_size;
        var pos_y = offset + player_tile_y * tile_size;
        var blue =  color {0.0, 0.0, 1.0, 1.0};
        draw_rectangle(render_target, center_half_size_rect(pos_x, pos_y, tile_size/2), blue);

        // draw player
        var player_color = color { 0.3, 0.5, 0.8, 1.0 };
        var px = game_state.player_x;
        var py = game_state.player_y;
        var player_size = tile_size / 2;
        draw_rectangle(render_target, center_half_size_rect(Math.round_to_i32(px), Math.round_to_i32(py), player_size/2), player_color);
        
        // draw mouse cursor
        var red = color {0.5, 0.5, 0.5, 1.0};
        let cursor_size = 15;
        if (!input.left_mb.pressed) {
            draw_rectangle(render_target, center_half_size_rect(input.mouse_x, input.mouse_y, cursor_size), red);
        } else {
            draw_rectangle(render_target, center_half_size_rect(input.mouse_x, input.mouse_y, cursor_size + 5), red);   
        }
        
        consume_buttons(input);
        return result;
    }

    let animate_background_color = fun
    (
        @background_color: color*;
        t: f32;
    ) => void
    {
        r += 0.25 * Math.sin(t * 5.0);
        g += 0.25 * Math.sin(t * 4.2 + 0.5);
        b += 0.25 * Math.cos(t * 5.1);
    }

    ["dll.export"]
    let game_output_sound = fun
    (
        game_memory: game_memory*; 
        @sound_output: game_sound_output*;
    ) => void
    {
        var game_state = get_game_state(game_memory);
        var wave_period = 2 * Math.pi_32;
        var sample = sample_out;
        assert((ptr)sample != nullptr);

        // var t_sine = game_state.t_sine;
        // var phase_shift = 2*Math.pi_32*t_sine * (game_state.tone_hz - game_state.target_tone_hz)
        //                 + game_state.phase_shift;
        // game_state.tone_hz = game_state.target_tone_hz;
        // var delta_t = 1.0 / (f32)samples_per_second;
        // for (var i: i32 = 0; i < sample_count; ++i) {
        //     var t = (f32)i / (f32)(sample_count - 1);
        //     var v = Math.lerp(game_state.volume, game_state.target_volume, t);
        //     var p = game_state.tone_hz * wave_period * t_sine;
            
        //     var x = (i16)(32767 * v * Math.sin(p + phase_shift));
        //     *sample++ = x;
        //     *sample++ = x;
        //     t_sine += delta_t;
        // }
        
        // game_state.t_sine = t_sine;
        // game_state.phase_shift = phase_shift;
        // game_state.volume = game_state.target_volume;
    }

    let get_game_state = fun (memory: game_memory*) => game_state* 
    {
        var game_state = (game_state*)memory.permanent_data;
        if (!game_state.is_initialized) {
            game_state.is_initialized = true;
            game_state.player_x = 610;
            game_state.player_y = 50;
            game_state.new_player_x = game_state.player_x;
            game_state.new_player_y = game_state.player_y;
        }
        return game_state;
    }

    let handle_player_input = fun 
    (
        @game_state: game_state*;
        @game_input: game_input*; 
    ) => void 
    {
        if (request_quit && !exit) {
            exit = true;
        }
   
        var delta_x = 0.0;
        var delta_y = 0.0;

        if (up_arrow.pressed) {
            delta_y -= 1;
        }
        if (down_arrow.pressed) {
            delta_y += 1;
        }
        if (left_arrow.pressed) {
            delta_x -= 1;
        }
        if (right_arrow.pressed) {
            delta_x += 1;
        }
        delta_x *= 128;
        delta_y *= 128;
        new_player_x = player_x + delta_x * time.dt;
        new_player_y = player_x + delta_y * time.dt;
    }

    let consume_buttons = fun
    (
        @input: game_input*;
    ) => void
    {
        consume_button(&up_arrow);
        consume_button(&down_arrow);
        consume_button(&left_arrow);
        consume_button(&right_arrow);
        consume_button(&left_mb);
        consume_button(&right_mb);
        consume_button(&middle_mb);
    }

    let consume_button = fun
    (
        @button: game_button*;
    ) => void
    {
        down = false;
        up = false;
    }

    let draw_rectangle = fun
    (
        buffer: game_render_target*;
        rect: rectangle;
        color: color;
    ) => void
    {
        var min_x_p = (i32)Math.round(rect.pos.x);
        var min_y_p = (i32)Math.round(rect.pos.y);
        var max_x_p = (i32)Math.round(rect.pos.x + rect.size.x);
        var max_y_p = (i32)Math.round(rect.pos.y + rect.size.y);
        if (min_x_p < 0) {
            min_x_p = 0;
        }
        if (min_y_p < 0) {
            min_y_p = 0;
        }
        if (max_x_p > buffer.width) {
            max_x_p = buffer.width;
        }
        if (max_y_p > buffer.height) {
            max_y_p = buffer.height;
        }

        var r = (i32)Math.round(color.r * 255);
        r = Math.clamp_i32(r, 0, 255);
        var g = (i32)Math.round(color.g * 255);
        g = Math.clamp_i32(g, 0, 255);
        var b = (i32)Math.round(color.b * 255);
        b = Math.clamp_i32(b, 0, 255);
        var c = (r << 16) | (g << 8) | (b << 0);

        var row: i8* = buffer.memory;
        row += min_y_p * buffer.pitch;
        row += 4 * min_x_p;
        for (var y = min_y_p; y < max_y_p; ++y) {
            var pixel = (i32*)row;
            for (var x = min_x_p; x < max_x_p; ++x) {
                *(pixel++) = c;    
            }    
            row += buffer.pitch;
        }
    }

    [
    "compile.entry",
    "compile.cpu"   : "nehalem",
    "compile.dll"   : "true",
    "compile.output": "handmade.dll",
    "compile.opt"   : "0",
    "compile.ll"   : "false",
    "compile.run"   : "false",
    "compile.path"  : "C:\Program Files (x86)\Windows Kits\10\Lib\10.0.14393.0\um\x64, lib",
    "compile.libs"  : "kernel32.lib, libopenlibm.a"
    ]
    let main = fun () => void  
    {
    }
}