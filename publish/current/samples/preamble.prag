#if PLATFORM_WINDOWS
	import "windows.prag"
#endif
import "memory.prag"

var temp_memory_arena: memory_arena = create_arena(megabytes(32));

let kilobytes = fun (bytes: mm) => mm 
{
	return bytes * 1024 ;
}
let megabytes = fun (bytes: mm) => mm 
{
	return bytes * 1024 * 1024;
}
let gigabytes = fun (bytes: mm) => mm
{
	return bytes * 1024 * 1024 * 1024;
}
let terabytes = fun (bytes: mm) => mm
{
	return bytes * 1024 * 1024 * 1024 * 1024;
}

let null = @mm 0;
let nullptr = @ptr 0;

["stub"]
let _rdtsc = extern fun () => i64;

["stub"]
let __chkstk = extern fun () => void;


#if PLATFORM_WINDOWS
	let print = fun (s: string) => void	{
		assert(Windows::console_output_handle != Windows::INVALID_HANDLE_VALUE);
		Windows::WriteFile(Windows::console_output_handle, s.data, s.length, @i32* nullptr, nullptr);
	}
	let print_error = fun (s: string) => void {
		assert(Windows::console_error_handle != Windows::INVALID_HANDLE_VALUE);
		Windows::WriteFile(Windows::console_error_handle, s.data, s.length, @i32* nullptr, nullptr);
	}
	let allocate = fun(size: mm) => ptr {
		var result = Windows::VirtualAlloc(0@ptr, size, Windows::MEM_COMMIT | Windows::MEM_RESERVE, Windows::PAGE_READWRITE);
		return result;
	}
	let free = fun(p: ptr) => void 	{
		Windows::VirtualFree(p, null, Windows::MEM_RELEASE);
	}
	let readln = fun(arena: memory_arena* = &temp_memory_arena) => string {
		var result = string {};
		result.data = push(arena, 256);
		result.length = 256;
		Windows::SetConsoleMode(Windows::console_input_handle,  
			Windows::ENABLE_LINE_INPUT | Windows::ENABLE_ECHO_INPUT |  Windows::ENABLE_PROCESSED_INPUT );
		Windows::ReadFile(Windows::console_input_handle, result.data, result.length, &result.length, nullptr);
		result.length -= 2;
		if (result.length < 0) {
			result.length = 0;
		}
		return result;
	}
	let CopyMemory = extern("RtlCopyMemory") fun (dest: ptr; src: ptr; length: mm) => void;
#ENDIF

let make_string = fun(length: i32; arena: memory_arena* = &temp_memory_arena) => string {
	var result = string {};
	result.data = push(arena, @mm length);
	memset(result.data, 0, @mm result.length);
	result.length = length;
	return result;
}

let concat = fun(a: string; b: string; arena: memory_arena* = &temp_memory_arena) => string {
	var result = make_string(a.length + b.length, arena);
	memcpy(result.data, a.data, @mm a.length);
	memcpy(result.data + a.length, b.data, @mm b.length);
	return result;
}

let from_str = fun(str: string; value: i32*) => bool {
	var result = 0;
	var sign = 1;
	if (str.length < 1) {
		return false;
	}
	var first_digit_idx = 0;
	if (str[0] == ord("+")@i8 || str[0] == ord("-")@i8) {
		first_digit_idx = 1;
		if (str[0] == ord("-")@i8) {
			sign = -1;
		}
	}
	var decimal_factor = 1;
	for (var str_idx = str.length - 1; str_idx >= first_digit_idx; --str_idx) {
		var chr = str[str_idx]@i32;
		var current_digit: i32;
		if (chr == ord("0")) {
			current_digit = 0;
		}
		elif (chr == ord("1")) {
			current_digit = 1;
		}
		elif (chr == ord("2")) {
			current_digit = 2;
		}
		elif (chr == ord("3")) {
			current_digit = 3;
		}
		elif (chr == ord("4")) {
			current_digit = 4;
		}
		elif (chr == ord("5")) {
			current_digit = 5;
		}
		elif (chr == ord("6")) {
			current_digit = 6;
		}
		elif (chr == ord("7")) {
			current_digit = 7;
		}
		elif (chr == ord("8")) {
			current_digit = 8;
		}
		elif (chr == ord("9")) {
			current_digit = 9;
		}		
		else { 
			return false;
		}
		result += current_digit * decimal_factor;
		decimal_factor *= 10;
	}
	*value = sign * result;
	return true;
}

let from_hex_str = fun(str: string; value: i32*) => bool {
	var result = 0;
	var sign = 1;
	if (str.length < 1) {
		return false;
	}
	var first_digit_idx = 0;
	if (str[0] == ord("+")@i8 || str[0] == ord("-")@i8) {
		first_digit_idx = 1;
		if (str[0] == ord("-")@i8) {
			sign = -1;
		}
	}
	var hex_factor = 1;
	for (var str_idx = str.length - 1; str_idx >= first_digit_idx; --str_idx) {
		var chr = str[str_idx]@i32;
		var current_digit: i32;
		if (chr == ord("0")) {
			current_digit = 0;
		}
		elif (chr == ord("1")) {
			current_digit = 1;
		}
		elif (chr == ord("2")) {
			current_digit = 2;
		}
		elif (chr == ord("3")) {
			current_digit = 3;
		}
		elif (chr == ord("4")) {
			current_digit = 4;
		}
		elif (chr == ord("5")) {
			current_digit = 5;
		}
		elif (chr == ord("6")) {
			current_digit = 6;
		}
		elif (chr == ord("7")) {
			current_digit = 7;
		}
		elif (chr == ord("8")) {
			current_digit = 8;
		}
		elif (chr == ord("9")) {
			current_digit = 9;
		}
		elif (chr == ord("a") || chr == ord("A")) {
			current_digit = 10;
		}		
		elif (chr == ord("b") || chr == ord("B")) {
			current_digit = 11;
		}		
		elif (chr == ord("c") || chr == ord("C")) {
			current_digit = 12;
		}		
		elif (chr == ord("d") || chr == ord("D")) {
			current_digit = 13;
		}		
		elif (chr == ord("e") || chr == ord("E")) {
			current_digit = 14;
		}		
		elif (chr == ord("f") || chr == ord("F")) {
			current_digit = 15;
		}		
		else { 
			return false;
		}
		result += current_digit * hex_factor;
		hex_factor *= 16;
	}
	*value = sign * result;
	return true;
}

let to_hex_str = fun(value: i32; arena: memory_arena* = &temp_memory_arena) => string {
	var result = make_string(8, arena);
	var temp = value;
	
	for (var str_idx = 7; str_idx >= 0; --str_idx) {
		var digit = temp & 0xF;
		var char: i32;
		if (digit == 0) {
			char = ord("0");
		}
		elif (digit == 1) {
			char = ord("1");
		}
		elif (digit == 2) {
			char = ord("2");
		}
		elif (digit == 3) {
			char = ord("3");
		}
		elif (digit == 4) {
			char = ord("4");
		}
		elif (digit == 5) {
			char = ord("5");
		}
		elif (digit == 6) {
			char = ord("6");
		}
		elif (digit == 7) {
			char = ord("7");
		}
		elif (digit == 8) {
			char = ord("8");
		}
		elif (digit == 9) {
			char = ord("9");
		}
		elif (digit == 10) {
			char = ord("A");
		}
		elif (digit == 11) {
			char = ord("B");
		}
		elif (digit == 12) {
			char = ord("C");
		}
		elif (digit == 13) {
			char = ord("D");
		}
		elif (digit == 14) {
			char = ord("E");
		}
		elif (digit == 15) {
			char = ord("F");
		}
		result[str_idx] = @i8 char;
		temp >>=\ 4;
	}	
	// var offset = str_idx + 1;
	// result.data += offset;
	// result.length -= offset;
	return result;
}
let to_str = fun(value: i32; signed: bool = true; arena: memory_arena* = &temp_memory_arena) => string {
	var result = make_string(11, arena);
	var temp = value;
	
	var negative = false;
	if (signed) {
		if (temp < 0) {
			temp = - temp;
			negative = true;
		}
	}
	var str_idx = 10;
	
	for (; str_idx >= 0; --str_idx) {
		var digit = temp % 10;
		var char: i32;
		if (digit == 0) {
			char = ord("0");
		}
		elif (digit == 1) {
			char = ord("1");
		}
		elif (digit == 2) {
			char = ord("2");
		}
		elif (digit == 3) {
			char = ord("3");
		}
		elif (digit == 4) {
			char = ord("4");
		}
		elif (digit == 5) {
			char = ord("5");
		}
		elif (digit == 6) {
			char = ord("6");
		}
		elif (digit == 7) {
			char = ord("7");
		}
		elif (digit == 8) {
			char = ord("8");
		}
		elif (digit == 9) {
			char = ord("9");
		}
		result[str_idx] = @i8 char;
		temp /= 10;
		if (temp == 0) {
			break;
		}
	}	
	
	if (signed && negative) {
		result[--str_idx] = @i8 ord("-");
	}
	
	var offset = str_idx;
	result.data += offset;
	result.length -= offset;
	return result;
}

["conditional":"debug"]
let assert = fun 
(
	value: bool; 
	msg: string = ""; 
	filepos: string = __file_pos__();
) => void 
{
	if (!value) {
		print_error("Assertion "); 
		if (msg.length > 0) 
		{
			print_error("\"");
			print_error(msg);
			print_error("\" ");
		}
		print_error("failed at: ");
		print_error(filepos);
		print_error("\n");
		*nullptr = 42;
	}
}

#if DEBUG
let cstr = fun(value: string; filepos: string = __file_pos__()) => i8* 
{
	assert(value[value.length - 1] == 0, "c-string not null terminated", filepos);
	return value.data;
}
#else
let cstr = fun(value: string) => i8* 
{
	return value.data;
}
#endif

let from_cstr = fun(cstr: ptr; maxLength: i32 = 1024) => string {
	var result: string;
	result.data = cstr;
	result.length = 0;
	var ptr = cstr;
	while (*ptr++ != 0 && result.length <\ maxLength) {
		result.length++;
	}
	return result;
}

let ord = fun(value: string) => i32
{
	assert(value.length == 1);
	return @i32 value[0];
}

let strings_are_equal = fun(a: string; b: string) => bool {
	if (a.length != b.length) {
		return false;
	}
	for (var idx = 0; idx < a.length; ++idx) {
		if (a[idx] != b[idx]) {
			return false;
		}
	}
	return true;
}

let is_end_of_line = fun(char: i8) => bool {
	var result = char == 10 || char == 13;
	return result;
}

let is_whitespace = fun(char: i8) => bool {
	var result = char == 32 || char == 09 || char == 11 || char == 12 || is_end_of_line(char);
	return result;
}

// let __chkstk = fun() => void 
// {
// 	return;
// }
// https://raw.githubusercontent.com/Microsoft/compiler-rt/8902445ef0cb23430ab6d9e3213c02c23752196d/lib/builtins/x86_64/chkstk.S
// https://github.com/Microsoft/compiler-rt/blob/8902445ef0cb23430ab6d9e3213c02c23752196d/lib/builtins/i386/chkstk.S
// void __chkstk() 
// {
// 	 __asm__ ( "push   %rcx \t\n"
//                "push   %rax \t\n"
//                "cmp    $0x1000,%rax \t\n"
//                "lea    24(%rsp),%rcx \t\n"
//                "jb     1f \t\n"
//                "2: \t\n"
//                "sub    $0x1000,%rcx \t\n"              
//                "orl    $0,(%rcx) \t\n"
//                "sub    $0x1000,%rax \t\n"              
//                "cmp    $0x1000,%rax \t\n"              
//                "ja     2b \t\n"              
//                "1: \t\n"
//                "sub    %rax,%rcx \t\n"
//                "orl    $0,(%rcx) \t\n"
//                "pop    %rax \t\n"
//                "pop    %rcx \t\n"
//                "ret \t\n"
//     );
// }
// // https://git.musl-libc.org/cgit/musl/tree/src/math
// let fmodf = fun(x: f32; y: f32) => f32
// {
// 	var result = x / y;
// 	return 3.0;
// }


// TODO make a fast version
let memset = fun
(
	dest : ptr;
	value: i32;
	count: mm;
) => ptr
{
	var data = dest;
	while (data != (dest + count)) {
		*data++ = @\i8 value;
	}
	return dest;
}




	// TODO(pragma): READ/WRITE barrier?
    // https://godbolt.org/z/3a1fQJ
    // https://github.com/llvm-mirror/clang/blob/master/test/CodeGen/ms-barriers-intrinsics.c
    // fence syncscope("singlethread") seq_cst
    // fence syncscope("singlethread") seq_cst
    // _WriteBarrier()
    // _ReadBarrier()
let _WriteBarrier = fun() => void 
{
	__emit__("fence syncscope(\"singlethread\") seq_cst");
}

let _ReadBarrier = fun() => void 
{
	__emit__("fence syncscope(\"singlethread\") seq_cst");
}

let _ReadWriteBarrier = fun() => void 
{
	__emit__("fence syncscope(\"singlethread\") seq_cst");
}

let atomic_inc = fun(ptr: i32*) => i32
{
	return atomic_add(ptr, 1);
}

let atomic_inc = fun(ptr: i64*) => i64
{
	return atomic_add(ptr, 1);
}
let atomic_dec = fun(ptr: i32*) => i32
{
	return atomic_sub(ptr, 1);
}
let atomic_dec = fun(ptr: i64*) => i64
{
	return atomic_sub(ptr, 1);
}


let memcpy = fun(dest: ptr; src: ptr; length: mm) => void
{
	CopyMemory(dest, src, length);
}

let print = fun (value: i32; signed: bool = true) => void
{
	if (signed) {
		print(@i64 value, true);
	} else {
		print(@\i64 value, false);
	}
}


let print = fun (value: i64; signed: bool = true) => void
{
	var v = value;
	var pd: print_dest;
	pd.pos = 0;
	pd.buffer = "                                                                ";
	assert(pd.buffer.length == 64); 
	
	if (signed && v < 0) {
		v = -v;
		out_char(&pd, 45);
	}
	u64_to_ascii(&pd, v);
	pd.buffer.length = pd.pos;
	print(pd.buffer);
}

let print = fun (value: f32; precision: i32 = 4) => void
{
	print(@f64 value, precision);	
}

let print_dest = struct
(
	buffer: string;
	pos: i32;
);

let out_char = fun (dest: print_dest*; char: i8) => void
{
	assert(dest.pos >= 0 && dest.pos < dest.buffer.length);
	dest.buffer[dest.pos++] = char;
} 

var decimal_digits = "0123456789";
let u64_to_ascii = fun (dest: print_dest*; value: i64) => void
{
	let base = 10;
	var v = value;

	var start = &dest.buffer[dest.pos];
	while (true) {
		var index = @i32 (v % @i64 base);
		assert(index >= 0 && index < 10);
		var digit = decimal_digits[index];
		out_char(dest, digit);
		v /=\ @i64 base;
		if (v == 0) {
			break;
		}
	}
	var end = &dest.buffer[dest.pos];

	while(start <\ end) {
		--end;
		var temp = *end;
		*end = *start;
		*start = temp;
		++start;
	}
}
let print = fun (value: f64; precision: i32 = 4) => void
{
	var v = value;
	var pd: print_dest;
	pd.pos = 0;
	pd.buffer = "                                                                ";
	assert(pd.buffer.length == 64); 

	if (v < 0) {
		v = -v;
		out_char(&pd, 45);
	}
	var int_part = @\i64 v;
	u64_to_ascii(&pd, int_part);
	v -= @f64 int_part;
	out_char(&pd, 46);

	var first_fraction_char = pd.pos;
	var last_non_zero = pd.pos;
	for (var i = 0; i < precision; ++i) {
		v *= 10.0;
		var int_part = @i32 v;
		v -= @f64 int_part;
		assert(int_part < 10 && int_part >= 0);
		out_char(&pd, decimal_digits[int_part]);
		if (int_part != 0) {
			last_non_zero = pd.pos;
		} 
	}
	assert(pd.pos <= pd.buffer.length);
	pd.buffer.length = pd.pos;
	print(pd.buffer);
}

let print = fun (value: f32_4x; precision: i32 = 4) => void
{
	print("< ");
	print(value[0], precision);
	print(", ");
	print(value[1], precision);
	print(", ");
	print(value[2], precision);
	print(", ");
	print(value[3], precision);
	print(" >");
}

let debug_print = fun(name: string; value: string) => void {
	print(name);
	print(": ");
	print(value);
	print("\n");
}	

let debug_print = fun (name: string; value: i64; signed: bool = true) => void
{
	print(name);
	print(": ");
	print(value, signed);
	print("\n");
}
let debug_print = fun (name: string; value: i32; signed: bool = true) => void
{
	print(name);
	print(": ");
	print(value, signed);
	print("\n");
}
let debug_print = fun (name: string; value: f32; precision: i32 = 4) => void
{
	print(name);
	print(": ");
	print(value, precision);
	print("\n");
}
let debug_print = fun (name: string; value: f64; precision: i32 = 4) => void
{
	print(name);
	print(": ");
	print(value, precision);
	print("\n");
}

let debug_print = fun (name: string; value: bool) => void
{
	print(name);
	print(": ");
	if (value) {
		print("true");
	} else {
		print("false");
	}
	print("\n");
}

let debug_print = fun(name: string; value: f32_4x) => void
{
	print(name);
	print(": < ");
	print(value[0]);
	print(", ");
	print(value[1]);
	print(", ");
	print(value[2]);
	print(", ");
	print(value[3]);
	print(" >\n");
}
let debug_print = fun(name: string; value: i32_4x) => void
{
	print(name);
	print(": < ");
	print(value[0]);
	print(", ");
	print(value[1]);
	print(", ");
	print(value[2]);
	print(", ");
	print(value[3]);
	print(" >\n");
}

var _fltused = 0;
let __hack_reserve_intrinsics = fun () => bool
{
	if (@mm memcpy == 1234 || @mm memset == 1234 || @mm __chkstk == 1234 || @mm (&_fltused) == 1234) {
		
		print("");
		return true;
	}
	return false;
}
var __intrinsics = __hack_reserve_intrinsics();