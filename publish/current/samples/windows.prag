mod Windows
{

    let STD_ERROR_HANDLE  = -12;
    let STD_OUTPUT_HANDLE = -11;
    let STD_INPUT_HANDLE  = -10;
    let INVALID_HANDLE_VALUE:mm = 0xFFFFFFFF;

    var console_output_handle = GetStdHandle(STD_OUTPUT_HANDLE);
    var console_input_handle = GetStdHandle(STD_INPUT_HANDLE);
    var console_error_handle = GetStdHandle(STD_ERROR_HANDLE);

    let WS_OVERLAPPEDWINDOW = 13565952;
    let WS_OVERLAPPED = 0x00000000;
    let WS_CAPTION = 0x00C00000;
    let WS_SYSMENU = 0x00080000;
    let WS_MINIMIZEBOX = 0x00020000;
    let WS_MAXIMIZEBOX = 0x00010000;
    let WS_VISIBLE    = 0x10000000; 
    let WS_EX_TOPMOST = 0x00000008;


    let CW_USEDEFAULT = 0x80000000;
    let CS_OWNDC   = 0x0020;
    let CS_HREDRAW = 0x0002;
    let CS_VREDRAW = 0x0001;
    let WM_PAINT = 15;
    let WM_CLOSE = 16;
    let WM_DESTROY = 2;
    let WM_SIZE = 5;
    let WM_SIZING = 0x0214;
    let WM_QUIT = 18;
    let WM_SYSKEYDOWN = 260;
    let WM_SYSKEYUP = 261;
    let WM_KEYDOWN = 256;
    let WM_KEYUP = 257;
    let WHITENESS = 16711778;
    let BLACKNESS = 66;
    let SRCCOPY = 13369376;
    let DIB_RGB_COLORS = 0;
    let BI_RGB = 0;
    let MEM_COMMIT     = 0x00001000;
    let MEM_RESERVE    = 0x00002000;
    let MEM_RESET      = 0x00008000;
    let MEM_RESET_UNDO = 0x10000000;
    let MEM_LARGE_PAGES= 0x20000000;
    let PAGE_READWRITE = 0x04;
    let MEM_RELEASE = 0x8000;
    let PM_NOREMOVE = 0x0000;
    let PM_REMOVE = 0x0001;
    let PM_NOYIELD = 0x0002;

    
    let VK_LBUTTON = 0x01;
    let VK_RBUTTON = 0x02;
    let VK_MBUTTON = 0x04;
    let VK_ESCAPE  = 0x1B;
    let VK_UP      = 0x26;
    let VK_DOWN    = 0x28;
    let VK_LEFT    = 0x25;
    let VK_RIGHT   = 0x27;
    let VK_SPACE   = 0x20;

    ["packed"]
    let WNDCLASSEX = struct 
    (
      cbSize: i32;
      style: i32;
      lpfnWndProc: i8*;
      cbClsExtra: i32;
      cbWndExtra: i32;
      hInstance: mm;
      hIcon: mm;
      hCursor: mm;
      hbrBackground: mm;
      lpszMenuName: i8*;
      lpszClassName: i8*;
      hIconSm: mm;
    );

    
    ["packed"]
    let POINT = struct 
    (
      x: i32;
      y: i32;
    );
    ["packed"]
    let MSG = struct
    (
      hwnd: mm;
      message: i32;
      wParam: mm;
      lParam: mm;
      time: i32;
      pt: POINT;
      pad: mm;
    );
    ["packed"]
    let RECT = struct 
    (
      left: i32;
      top: i32;
      right: i32;
      bottom: i32;
    );
    ["packed"]
    let PAINTSTRUCT = struct
    (
      hdc: mm;
      fErase: i32;
      rcPaint: RECT;
      fRestore: i32;
      fIncUpdate: i32;
      reserved0: mm;
      reserved1: mm;
      reserved2: mm;
      reserved3: mm;
    );
    ["packed"]
    let BITMAPINFOHEADER = struct
    (
      biSize: i32;
      biWidth: i32;
      biHeight: i32;
      biPlanes: i16;
      biBitCount: i16;
      biCompression: i32;
      biSizeImage: i32;
      biXPelsPerMeter: i32;
      biYPelsPerMeter: i32;
      biClrUsed: i32;
      biClrImportant: i32;
    );
    ["packed"]
    let RGBQUAD = struct 
    (
      blue: i8;
      green: i8;
      red: i8;
      reserved: i8;
    );
    ["packed"]
    let BITMAPINFO = struct
    (
      header: BITMAPINFOHEADER;
      rgb: RGBQUAD;
    );

    let GENERIC_READ    = 0x80000000;
    let GENERIC_WRITE   = 0x40000000;
    let FILE_SHARE_READ = 1;
    let CREATE_ALWAYS   = 2;
    let OPEN_EXISTING   = 3;

    let CreateFileA = extern fun
    (
      FileName: i8*;
      DesiredAccess: i32;
      SharedMode: i32;
      SecurityAttributes: ptr;
      CreationDisposition: i32;
      FlagsAndAttributes: i32;
      TemplateFile: mm;
    ) => mm;

    let WriteFile = extern fun
    (
      hFile: mm;
      // ["LLVM.NoCapture"]
      lpBuffer: i8*;
      nNumberOfBytesToWrite: i32;
      // ["LLVM.NoCapture"]
      lpNumberOfBytesWritten: i32*;
      lpOverlapped: ptr;
    ) => i32;

    let CopyFileA = extern fun
    (
      source: i8*;
      dest: i8*;
      fail_if_exists: i32;
    ) => i32;

    let ReadFile = extern fun
    (
      hFile: mm;
      lpBuffer: ptr;
      nNumberOfBytesToRead: i32;
      nNumberOfBytesRead: i32*;
      lpOverlapped: ptr;
    ) => i32;

    let GetFileTime = extern fun 
    (
      hFile: mm;
      CreationTime: i64*;
      LastAccessTime: i64*;
      LastWriteTime: i64*;
    ) => i32;

  
    ["packed"]
    let WIN32_FILE_ATTRIBUTE_DATA = struct
    (
      FileAttributes: i32;
      CreationTime:   i64;
      LastAccessTime: i64;
      LastWriteTime:  i64;
      FileSize:       i64;
    );

    let GetFileExInfoStandard = 0;
    let GetFileAttributesExA = extern fun
    (
      filename: i8*;
      flags: i32;
      data: WIN32_FILE_ATTRIBUTE_DATA*;
    ) => i32;

    ["packed"]
    let WIN32_FIND_DATA = struct
    (
      FileAttributes: i32;
      CreationTime: i64;
      LastAccessTime: i64;
      LastWriteTime: i64;
      FileSize: i64;
      Reserved: i64;
      FileName: i8[260];
      AlternateFileName: i8[14];
    ); 
    let FindFirstFileA = extern fun
    (
      FileName: i8*;
      FindData: WIN32_FIND_DATA*;
    ) => mm;

    let FindClose = extern fun 
    (
      handle: mm;
    ) => i32;

    let GetFileSizeEx = extern fun
    (
      hFile: mm;
      FileSizeHigh: i64*;
    ) => i32;


    let GetLastError = extern fun () => i32;
    let GetStdHandle = extern fun (nStdHandle: i32) => mm;
    let GetModuleHandleA = extern fun (lpModuleName: mm) => mm;
    let RegisterClassExA = extern fun (window_class: WNDCLASSEX*) => i16;
    let DefWindowProcA = extern fun (window: mm; message: i32; w_param: mm; l_param: mm) => mm;
    let ExitProcess = extern fun(signal: i32) => void;
    
    let CreateWindowExA = extern fun
    (
       dwExStyle: i32;     
       lpClassName: i8*;
       lpWindowName: i8*;
       dwStyle: i32;
       x: i32;
       y: i32;
       nWidth: i32;
       nHeight: i32;
       hWndParent: mm;
       hMenu: mm;
       hInstance: mm;
       lpParam: mm;
    ) => mm;

    let DestroyWindow = extern fun(
      hWnd: mm;
    ) => i32;

    let GetMessageA = extern fun
    (
      message: MSG*;
      hWnd: mm;
      wMsgFilterMin: i32;
      wMsgFilterMax: i32;
    ) => i32;
    let PeekMessageA = extern fun
    (
      message: MSG*;
      hWnd: mm;
      wMsgFilterMin: i32;
      wMsgFilterMax: i32;
      wRemoveMsg: i32;
    ) => i32;

    let TranslateMessage = extern fun (message: MSG*) => i32;
    let DispatchMessageA = extern fun (message: MSG*) => mm;
    let BeginPaint = extern fun (hwnd: mm; lpPaint: PAINTSTRUCT*) => mm;
    let EndPaint = extern fun (hwnd: mm; lpPaint: PAINTSTRUCT*) => i32;
    let PostQuitMessage = extern fun (nExitCode: i32) => void;
    let GetClientRect = extern fun (hWnd: mm; rect: RECT*) => i32;
    let CreateDIBSection = extern fun 
    (
      hdc: mm;
      bitmap: BITMAPINFO*;
      iUsage: i32;
      ppvBits: ptr*;
      hSection: mm; 
      dwOffset: i32
    ) => mm;

    let StretchDIBits = extern fun 
    (
      hdc: mm;
      xDest: i32;
      yDest: i32;
      nDestWidth: i32;
      nDestHeight: i32;
      XSrc: i32;
      YSrc: i32;
      nSrcWidth: i32;
      nSrcHeight: i32;
      lpBits: ptr;
      lpBitsInfo: BITMAPINFO*;
      iUsage: i32;
      dwRop: i32;
    ) => i32;

    let AdjustWindowRectEx = extern fun 
    (
       lpRect: RECT*;
       dwStyle: i32;
       bMenu: i32;
       dwExStyle: i32;
    ) => i32;

    // gdi32.lib
    let PatBlt = extern fun 
    (
      hdc: mm;
      nXLeft: i32;
      nYLeft: i32;
      nWidth: i32;
      nHeight: i32;
      dwRop: i32;
    ) => i32;

    let CloseHandle = extern fun (handle: mm) => i32;
    let DeleteObject = extern fun (obj: mm) => i32;
    let CreateCompatibleDC = extern fun (hdc: mm) => mm;
    let GetDC = extern fun (hWnd: mm) => mm;
    let ReleaseDC = extern fun (hWnd: mm; hdc: mm) => i32;
    let GetCompatibleDC = extern fun (hdc: mm) => mm;

    let VirtualAlloc = extern fun 
    (
      address: ptr;
      size: mm;
      allocation_type: i32;
      protect: i32;
    ) => ptr;

    let VirtualFree = extern fun
    (
      address: ptr;
      size: mm;
      free_type: i32;
    ) => i32;

    let LoadLibraryA = extern fun (name: i8*) => mm;
    let FreeLibrary = extern fun (lib: mm) => i32;
    let GetProcAddress = extern fun(lib: mm; name: i8*) => ptr;

    let QueryPerformanceCounter = extern fun(result: i64*) => i32;
    let QueryPerformanceFrequency = extern fun(result: i64*) => i32;
    let Sleep = extern fun (ms: i32) => void;
    let timeBeginPeriod = extern fun (ms: i32) => i32;
    let VREFRESH = 116;
    let GetDeviceCaps = extern fun (hdc: mm; index: i32) => i32;

    let IDC_ARROW:mm = 32512;

    let LoadCursorA = extern fun(hInstance: mm; cursor: mm) => mm;
    let GetCursorPos = extern fun(pos: POINT*) => i32;
    let GetKeyState = extern fun(vk: i32) => i16;
    let ScreenToClient = extern fun(wnd: mm; pos: POINT*) => i32;



    let ThreadProc = fun (param: ptr) => i32;
    let CreateThread = extern fun 
    (
      lpThreadAttributes: ptr;
      dwStackSize: mm;
      lpStartAddress: ThreadProc;
      lpParameter: ptr;
      dwCreationFlags: i32;
      lpThreadId: mm*;
    ) => mm;

    let SwapBuffers = extern fun(hdc: mm) => i32;

    ["PACKED"]
    let PIXELFORMATDESCRIPTOR = struct(
      nSize: i16;
      nVersion: i16;
      dwFlags: i32;
      iPixelType: i8;
      cColorBits: i8;
      cRedBits: i8;
      cRedShift: i8;
      cGreenBits: i8;
      cGreenShift: i8;
      cBlueBits: i8;
      cBlueShift: i8;
      cAlphaBits: i8;
      cAlphaShift: i8;
      cAccumBits: i8;
      cAccumRedBits: i8;
      cAccumGreenBits: i8;
      cAccumBlueBits: i8;
      cAccumAlphaBits: i8;
      cDepthBits: i8;
      cStencilBits: i8;
      cAuxBuffers: i8;
      iLayerType: i8;
      bReserved: i8;
      dwLayerMask: i32;
      dwVisibleMask: i32;
      dwDamageMask: i32;
    );
    let SetPixelFormat = extern fun(
      hdc: mm;
      iPixelFormat: i32;
      ppfd: PIXELFORMATDESCRIPTOR*;
    ) => i32;
    let ChoosePixelFormat = extern fun(
      hdc: mm;
      ppfd: PIXELFORMATDESCRIPTOR*;
    ) => i32;
    let DescribePixelFormat = extern fun(
      hdc: mm;
      iPixelFormat: i32;
      bytes: i32;
      ppfd: PIXELFORMATDESCRIPTOR*;
    ) => i32;

    let PFD_TYPE_RGBA = 0;
    let PFD_TYPE_COLORINDEX = 1;
    let PFD_MAIN_PLANE = 0;
    let PFD_OVERLAY_PLANE = 1;
    let PFD_UNDERLAY_PLANE = (-1);
    
    let PFD_DOUBLEBUFFER = 0x00000001;
    let PFD_STEREO = 0x00000002;
    let PFD_DRAW_TO_WINDOW = 0x00000004;
    let PFD_DRAW_TO_BITMAP = 0x00000008;
    let PFD_SUPPORT_GDI = 0x00000010;
    let PFD_SUPPORT_OPENGL = 0x00000020;
    let PFD_GENERIC_FORMAT = 0x00000040;
    let PFD_NEED_PALETTE = 0x00000080;
    let PFD_NEED_SYSTEM_PALETTE = 0x00000100;
    let PFD_SWAP_EXCHANGE = 0x00000200;
    let PFD_SWAP_COPY = 0x00000400;
    let PFD_SWAP_LAYER_BUFFERS = 0x00000800;
    let PFD_GENERIC_ACCELERATED = 0x00001000;
    let PFD_SUPPORT_DIRECTDRAW = 0x00002000;
    let PFD_DIRECT3D_ACCELERATED = 0x00004000;
    let PFD_SUPPORT_COMPOSITION = 0x00008000;
    
    let PFD_DEPTH_DONTCARE = 0x20000000;
    let PFD_DOUBLEBUFFER_DONTCARE = 0x40000000;
    let PFD_STEREO_DONTCARE = 0x80000000;



        

    // ********************** XINPUT ********************** 

    let XUSER_MAX_COUNT = 4;
    let XINPUT_SUCCESS = 0;
    let XINPUT_DEVICE_NOT_CONNECTED = 1167;
    ["packed"]
    let XINPUT_GAMEPAD = struct
    (
      Buttons: i16; 
      LeftTrigger: i8;
      RightTrigger: i8;
      ThumbLX: i16;
      ThumbLY: i16;
      ThumbRX: i16;
      ThumbRY: i16; // 12
    );

    ["packed"]
    let XINPUT_STATE = struct
    (
      PacketNumber: i32;
      Gamepad: XINPUT_GAMEPAD;
    );

    var XInputGetState: fun 
    (
      dwUserIndex: i32;
      state : XINPUT_STATE*
    ) => i32;


    // ********************** DIRECTSOUND ********************** 

    let DS_OK = 0;
    let WAVE_FORMAT_PCM = @i16 1;
    let DSBCAPS_PRIMARYBUFFER = 1;
    let DSBCAPS_GETCURRENTPOSITION2 = 0x10000;
    let DSBPLAY_LOOPING = 1;
    let DSSCL_PRIORITY = 2;

    ["packed"]
    let WAVEFORMATEX = struct
    (
      formatTag: i16;
      nChannels: i16;
      nSamplesPerSec: i32;
      nAvgBytesPerSec: i32;
      nBlockAlign: i16;
      nBitsPerSample: i16;
      size: i16;
    );


    ["packed"]
    let DSBUFFERDESC = struct
    (
      size: i32;
      flags: i32;
      bufferBytes: i32;
      reserved: i32;
      fxFormat: WAVEFORMATEX*;
    ); 


    ["packed"]
    let IDirectSoundBuffer = struct
    (
      vtable: DirectSoundBufferFunctions*;
    );

    ["packed"]
    let DirectSoundBufferFunctions = struct
    (
      _unused0: ptr;
      _unused1: ptr;
      _unused2: ptr;

      _unused3: ptr; // GetCaps
      GetCurrentPosition: fun
      (
        this: IDirectSoundBuffer*;
        currentPlayCursor: i32*;
        currentWriteCursor: i32*;
      ) => i32;
      _unused4: ptr; // GetFormat
      _unused5: ptr; // GetVolume
      _unused6: ptr; // GetPan
      _unused7: ptr; // GetFrequency
      _unused8: ptr; // GetStatus
      _usused9: ptr; // Initialize
      Lock: fun
      (
        this: IDirectSoundBuffer*;
        writeCursor: i32;
        writeBytes: i32;
        audioRegion1: ptr*;
        audioRegion1Size: i32*;
        audioRegion2: ptr*;
        audioRegion2Size: i32*;
        flags: i32;
      ) => i32;
      Play: fun
      (
        this: IDirectSoundBuffer*;
        reserved: i32;
        priority: i32;
        flags: i32;
      ) => i32;
      _usused10: ptr; // SetCurrentPosition
      SetFormat: fun
      (
        this: IDirectSoundBuffer*;
        format: WAVEFORMATEX*;
      ) => i32;
      _usused11: ptr; // SetVolume
      _usused12: ptr; // SetPan
      _usused14: ptr; // SetFrequency
      Stop: fun
      (
      ) => i32;
      Unlock: fun
      (
        this: IDirectSoundBuffer*;
        audioRegion1: ptr;
        audioRegion1Size: i32;
        audioRegion2: ptr;
        audioRegion2Size: i32;
      ) => i32;
      _usused15: ptr;
    );

    ["packed"]
    let IDirectSound = struct
    (
      vtable: DirectSoundFunctions*;
    ); 

    ["packed"]
    let DirectSoundFunctions = struct
    (
      _unused0: ptr;
      _unused1: ptr;
      _unused2: ptr;
      CreateSoundBuffer: fun
      (
        this: IDirectSound*;
        desc: DSBUFFERDESC*;
        dsb: IDirectSoundBuffer**;
        unused: ptr;
      ) => i32;
      _unused3: ptr; // GetCaps
      _unused4: ptr; // DuplicateSoundBuffer
      SetCooperativeLevel: fun
      (
        this: IDirectSound*;
        hwnd: mm;
        level: i32;
      ) => i32;
      _unused5: ptr; // Compact
      _unused6: ptr; // GetSpeakerConfig
      _unused7: ptr; // SetSpeakerConfig
      _unused8: ptr; // Initialize
    );
}

