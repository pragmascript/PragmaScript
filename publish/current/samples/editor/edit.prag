import "../preamble.prag"
import "../math.prag"
import "../memory.prag"
import "../vec.prag"


import "edit_win.prag"
import "edit_opengl.prag"
import "edit_lexer.prag"


let max_line_length = 1024;
let max_undo_points = 1024;
let text_chunk_line_count = 512;
let draw_chunk_colors = false;
let spaces_to_indent = 4;
    
let cursor = struct(
    pos: v3i;
    last_valid_char_pos: i32;
    target_char_pos: i32;
    
    draw_cursor: bool;
    cursor_last_blink_time: f32;
    
    selection_active: bool;
    selection_start: v3i;
    
    clipboard: string;
    
    should_scroll_to_cursor: bool;
);

let document = struct(
    file_name: string;
    chunks: text_chunk*;
    chunks_count: i32;
    chunks_capacity: i32;
    idx: i32;
);
let panel_tab = struct(
    scroll_pos: v2;
    scroll_target: v2;
    document: document*;
    cursor: cursor;
    idx: i32;
);
let undo_chunk = struct(
    idx: i32;
    data: text_chunk;
);
let undo_point = struct(
    active_panel: editor_panel*;
    active_tab: panel_tab*;
    tab_data: panel_tab;
    document_chunks_count: i32;
    dirty_chunks: undo_chunk[];
);
let global_render_state = struct(
    font: font;
    font_size: f32;
    target_font_size: f32;
    
    color_scale: f32;
    target_color_scale: f32;
    color_scale_uniform_location: i32;
    time: f32;        
    delta_time: f32;
    temp_memory: memory_arena;
);
let editor_panel = struct(
    render_region: rect;
    visible_line_count: i32;
    tabs: panel_tab[];
    tabs_capacity: i32;
    active_tab: panel_tab*;
);
let character = struct(
    value: i8;
    token_type: i8;
);
let line = struct(
    length: i32;
    capacity: i32;
    chars: character*;
);
let text_chunk = struct(
    lines: line[];
    needs_syntax_highlight: bool;
    is_dirty_for_undo: bool;
);
let editor_state = struct(
    start_time_ticks: i64;
    last_keypress_time: f32;
    dirty_for_undo: bool;
    
    keyboard_state: i8*;
    shift_pressed: bool;
    control_pressed: bool;
    
    left_panel: editor_panel;
    right_panel: editor_panel;
    console_panel: editor_panel;
    active_panel: editor_panel*;
    
    documents: document[];
    documents_capacity: i32;
    
    global_render_state: global_render_state;
    
    undo_points: undo_point[];
    undo_pos: i32;
    
    text_panel_commands: editor_commmand[];
);

let command_context = struct(
    foo: i32;
);
let key_combo = struct(
    vk_code: i32;
    shift: bool;
    control: bool;
    alt: bool;
);
let editor_commmand = struct(
    key_combo: key_combo;
    command: fun(cmd: command_context*) => bool;
);

let from_ascii = fun(value: i8) => character {
    return character { value };
}

let create_text_chunk = fun() => text_chunk {
    var result: text_chunk;
    
    var lines_size = size_of(line) * text_chunk_line_count@mm;
    var chars_size = size_of(character) * (max_line_length@mm) * text_chunk_line_count@mm;
    var total_size = lines_size + chars_size;
    var memory = allocate(total_size);
    
    result.lines.data = memory@line*;
    result.lines.length = 0;
    result.needs_syntax_highlight = false;
    result.is_dirty_for_undo = true;
    memory += lines_size;
    
    var text_block_ptr = memory@character*;
    for (var line_idx = 0; line_idx < text_chunk_line_count; ++line_idx) {
        result.lines[line_idx].length = 0;
        result.lines[line_idx].capacity = max_line_length;
        result.lines[line_idx].chars = text_block_ptr;
        text_block_ptr += max_line_length;
    }
    
    return result;
}

let clone_text_chunk = fun(chunk: text_chunk*) => text_chunk {
    var result = create_text_chunk();
    result.lines.length = chunk.lines.length;
    for (var line_idx = 0; line_idx < chunk.lines.length; ++line_idx) {
        var dest = result.lines.data + line_idx;
        var src = chunk.lines.data + line_idx;
        dest.length = src.length;
        dest.capacity = src.capacity;
        memcpy(dest.chars@ptr, src.chars@ptr, size_of(character) * src.length@mm);
    }
    result.needs_syntax_highlight = chunk.needs_syntax_highlight;
    result.is_dirty_for_undo = chunk.is_dirty_for_undo;
    return result;
}

let recycle_chunk = fun(document_state: document*; chunk_idx: i32) => void {
    if (document_state.chunks_count == 0) {
        return;
    }
    assert(chunk_idx >= 0 && chunk_idx < document_state.chunks_count);
    var chunk = document_state.chunks + chunk_idx;
    free_chunk(chunk);
    for (var src_chunk_idx = chunk_idx + 1; src_chunk_idx < document_state.chunks_count; ++src_chunk_idx) {
        *(document_state.chunks + (src_chunk_idx - 1)) = *(document_state.chunks + src_chunk_idx);
    }
    document_state.chunks_count--;
}

let free_chunk = fun(chunk: text_chunk*) => void {
    free(chunk.lines.data@ptr);
}

let create_document = fun(idx: i32) => document {
    var result = document { };
    result.chunks_count = 0;
    result.chunks_capacity = 1024;
    result.chunks = allocate((result.chunks_capacity@mm) * size_of(text_chunk))@text_chunk*;
    add_empty_chunk(&result);
    result.chunks.lines.length = 1;
    result.idx = idx;
    return result;
}

let create_tab = fun(idx: i32; document: document*) => panel_tab {
    var result = panel_tab { };
    result.document = document;
    result.idx = idx;
    return result;
}

let create_panel = fun() => editor_panel {
    var result = editor_panel { };
    result.visible_line_count = 0;
    result.tabs_capacity = 1024;
    result.tabs.data = allocate(size_of(panel_tab) * result.tabs_capacity@mm)@panel_tab*;
    result.tabs.length = 0;
    result.active_tab = nullptr@panel_tab*;
    return result;
}

let create_editor_state = fun(editor_state: editor_state*) => void  {
    *editor_state = editor_state { };
    
    editor_state.documents_capacity = 1024;
    editor_state.documents.data = @document* allocate(@mm editor_state.documents_capacity * size_of(document));
    editor_state.documents.length = 0;
    
    editor_state.left_panel = create_panel();
    editor_state.right_panel = create_panel();
    editor_state.active_panel = &editor_state.left_panel;
    
    var global_render_state = &editor_state.global_render_state;
    editor_state.keyboard_state = allocate(256);
    
    editor_state.global_render_state.font_size = 32;
    editor_state.global_render_state.target_font_size = 32;
    editor_state.global_render_state.color_scale = 1.0;
    editor_state.global_render_state.target_color_scale = 1.0;
    editor_state.global_render_state.temp_memory = create_arena(megabytes(128));
    
    editor_state.undo_points.data = @undo_point* allocate(@mm max_undo_points * size_of(undo_point));
    editor_state.undo_points.length = 0;
    editor_state.undo_pos = 0;
}
var editor_state: editor_state;

let add_empty_chunk = fun(document: document*) => text_chunk* {
    assert(document.chunks_count + 1 <= document.chunks_capacity);
    var chunk_ptr = document.chunks + document.chunks_count;
    *chunk_ptr = create_text_chunk();
    document.chunks_count++;
    return chunk_ptr;
}

let is_printable = fun(char: i8) => bool {
    return char >= 32 & char <= 126;
}

let reset_cursor_blink = fun() => void {
    var cursor = &editor_state.active_panel.active_tab.cursor;
    cursor.draw_cursor = true;
    cursor.cursor_last_blink_time = editor_state.global_render_state.time;
}

let get_ordered_selection_bounds = fun(cursor: cursor*; first: v3i*; last: v3i*) => void {
    *first = cursor.selection_start;
    *last = cursor.pos;
    if (first.z > last.z) {
        var temp = *first;
        *first = *last;
        *last = temp;
    } elif (first.z == last.z) {
        if (first.y > last.y) {
            var temp = *first;
            *first = *last;
            *last = temp;
        }
        if (first.y == last.y && first.x > last.x) {
            var temp = *first;
            *first = *last;
            *last = temp;
        }
    }
}

let is_in_selection = fun(cursor: cursor*; char_idx: i32; line_idx: i32; chunk_idx: i32) => bool {
    if (!cursor.selection_active) {
        return false;
    }
    var first: v3i;
    var last: v3i;
    get_ordered_selection_bounds(cursor, &first, &last);
    
    var char_idx_temp = char_idx;
    var line_idx_temp = line_idx;
    var chunk_idx_temp = chunk_idx;
    
    if (chunk_idx > first.z && chunk_idx < last.z) {
        return true;
    }
    if (chunk_idx < first.z || chunk_idx > last.z) {
        return false;
    }
    if (chunk_idx == first.z && line_idx < first.y) {
        return false;
    }
    if (chunk_idx == last.z && line_idx > last.y) {
        return false;
    }
    var result = true;
    if (chunk_idx == first.z && line_idx == first.y) {
        if (char_idx < first.x) {
            result = false;
        }
    }
    if (chunk_idx == last.z && line_idx == last.y) {
        if (char_idx >= last.x) {
            result = false;
        }
    }
    return result;
}

let delete_selection = fun(tab: panel_tab*) => void {
    var document = tab.document;
    var cursor = &tab.cursor;
    assert(cursor.selection_active);
    
    var first: v3i;
    var last: v3i;
    get_ordered_selection_bounds(cursor, &first, &last);
    
    assert(cursor.pos.z < document.chunks_count);
    
    var chunks_to_delete = Math::max(0, last.z - first.z - 1);
    for (var d_idx = 0; d_idx < chunks_to_delete; ++d_idx) {
        var chunk_idx = last.z - d_idx - 1;
        assert(chunk_idx > first.z && chunk_idx < last.z);
        recycle_chunk(document, chunk_idx);
    }
    last.z -= chunks_to_delete;
    
    var c0 = document.chunks + first.z;
    var c1 = document.chunks + last.z;

    var dest_line = c0.lines[first.y];
    var dest_line_ptr = &c0.lines[first.y];
    var src_line = c1.lines[last.y];
    dest_line_ptr.length -= (dest_line.length - first.x);
    
    
    for (var char_idx = last.x; char_idx < src_line.length; ++char_idx) {
        *(dest_line.chars + (dest_line_ptr.length++)) = *(src_line.chars + char_idx);
    }
    
    if (first.z == last.z) {
        for (var line_idx = last.y; line_idx >= first.y + 1; --line_idx) {
            delete_line(document, first.z, line_idx, false);
        }
        c0.lines.length -= (last.y - first.y);
    } else {
        for (var line_idx = c0.lines.length - 1; line_idx >= first.y + 1; --line_idx) {
            delete_line(document, first.z, line_idx, false);
        }
        c0.lines.length -= (c0.lines.length - first.y - 1);
        
        for (var line_idx = last.y; line_idx >= 0; --line_idx) {
            delete_line(document, last.z, line_idx, false);
        }
        c1.lines.length -= (last.y + 1);
    }

    if (c0.lines.length == 0) {
        recycle_chunk(document, first.z);
    }
    if (c1.lines.length == 0) {
        recycle_chunk(document, last.z);
    }
    
    cursor.pos = first;
    cursor.selection_active = false;
}

let delete_line = fun(document: document*; chunk_idx: i32; target_line_idx: i32; decrement_line_count: bool = true) => void {
    var current_chunk = document.chunks + chunk_idx;
    for (var line_idx = target_line_idx; line_idx < current_chunk.lines.length - 1; ++line_idx) {
        var dest_line = current_chunk.lines[line_idx];
        var src_line = current_chunk.lines[line_idx + 1];
        memcpy(dest_line.chars@i8*, src_line.chars@i8*, (src_line.length@mm) * size_of(character));
        current_chunk.lines[line_idx].length = src_line.length;
    }
    current_chunk.lines[current_chunk.lines.length - 1].length = 0;
    if (decrement_line_count) {
        current_chunk.lines.length--;
        if (current_chunk.lines.length <= 0) {
            assert(current_chunk.lines.length == 0);
            recycle_chunk(document, chunk_idx);
        }
    }
    mark_dirty(current_chunk);
}

let indent_line = fun(line_ptr: line*; char_offset: i32) => void {
    var space = from_ascii(ord(" "));
    var char_x = char_offset;
    for (var indent_idx = 0; indent_idx < spaces_to_indent; ++indent_idx) {
        add_char_to_line(line_ptr, char_x++, space);
    }
}

let dedent_line = fun(line_ptr: line*) => void {
    var indent = get_line_indent(line_ptr);
    if (indent >= spaces_to_indent) {
        assert(line_ptr.length >= spaces_to_indent);
        for (var char_idx = spaces_to_indent; char_idx < line_ptr.length; ++char_idx) {
            *(line_ptr.chars + char_idx - spaces_to_indent) = *(line_ptr.chars + char_idx);
        }
        line_ptr.length -= spaces_to_indent;
    }
}

let change_indent_selection = fun(tab: panel_tab*; dedent: bool) => void {
    var document = tab.document;
    var first: v3i;
    var last: v3i;
    get_ordered_selection_bounds(&tab.cursor, &first, &last);
    for (var z_idx = first.z; z_idx <= last.z; ++z_idx) {
        var chunk = document.chunks + z_idx;
        var from_line = 0;
        var to_line = chunk.lines.length - 1;
        if (z_idx == first.z) {
            from_line = first.y;
        }
        if (z_idx == last.z) {
            to_line = last.y;
        }
        for (var y_idx = from_line; y_idx <= to_line; ++y_idx) {
            var line_ptr = &chunk.lines[y_idx];
            if (dedent) {
                dedent_line(line_ptr);
            } else {
                indent_line(line_ptr, 0);
            }
        }
    }
}

let get_line_indent = fun(line: line*) => i32 {
    var result = 0;
    while (result < line.length) {
        var char = line.chars + result;
        if (is_whitespace(char.value)) {
            result++;
        } else {
            break;
        }
    }
    return result;
}

// TODO(pragma): find first non empty line i guess?
let get_next_indent = fun(line: line*; char_pos: i32) => i32 {
    var result = get_line_indent(line);
    var pos = line.length - 1;
    
    while (pos >= 0) {
        var char = line.chars + pos;
        if (char.value == ord("{") && char_pos > pos) {
            result += spaces_to_indent;
            break;
        }
        elif (is_whitespace(char.value)) {
            pos--;
        }
        else {
            break;
        }
    }
    return result;
}

let left_is_whitespace = fun(line: line*; char_pos: i32) => bool {
    var result = true;
    assert(char_pos <= line.length);
    for (var char_idx = 0; char_idx < char_pos; ++char_idx) {
        var char = line.chars + char_idx;
        if (!is_whitespace(char.value)) {
            return false;
        }
    }
    return true;
}

let insert_line = fun(document: document*; chunk_idx: i32; target_line_idx: i32; src_line: line*; src_char_pos: i32; adjust_indentation: bool) => i32 {
    if (chunk_idx >= document.chunks_count) {
        add_empty_chunk(document);
    }
    var current_chunk = document.chunks + chunk_idx;
    var lines = current_chunk.lines;
    var start_line_idx = current_chunk.lines.length - 1;
    if (current_chunk.lines.length == text_chunk_line_count) {
        insert_line(document, chunk_idx + 1, 0, &current_chunk.lines[current_chunk.lines.length - 1], 0, false);
        start_line_idx = current_chunk.lines.length - 2;
    } else {
        current_chunk.lines.length++;
    }
    
    for (var line_idx = start_line_idx; line_idx >= target_line_idx; --line_idx) {
        var src_line = lines[line_idx];
        var dest_line = lines[line_idx + 1];
        memcpy(dest_line.chars@i8*, src_line.chars@i8*, (src_line.length@mm) * size_of(character));
        lines[line_idx + 1].length = src_line.length;
    }
    var new_line = lines[target_line_idx];
    
    var indent = 0;
    if (adjust_indentation) {
        indent = get_next_indent(src_line, src_char_pos);
        var space = from_ascii(ord(" "));
        for (var char_idx = 0; char_idx < indent; ++char_idx) {
            *(lines[target_line_idx].chars + char_idx) = space;
        }
    }
    if (src_line@ptr == nullptr || src_line.length == 0) {
        memset(new_line.chars@i8*, 0, (max_line_length@mm) * size_of(character));
        lines[target_line_idx].length = 0;
    } else {
        var char_count = (src_line.length - src_char_pos);
        memcpy((new_line.chars + indent)@i8*, (src_line.chars + src_char_pos)@i8*, @mm char_count * size_of(character));
        assert(indent + char_count < max_line_length);
        lines[target_line_idx].length = indent + char_count;
    }
    mark_dirty(current_chunk);
    assert(current_chunk.lines.length > 0);
    return indent;
}

let paste_string = fun(tab: panel_tab*; str: string) => void {
    var temp_tab = tab;
    var document = tab.document;
    var cursor = &tab.cursor;
    var current_chunk = document.chunks + cursor.pos.z;
    for (var idx = 0; idx < str.length; ++idx) {
        var char = str[idx];
        if (char == 13) {
            continue;
        }
        var chunk = document.chunks + cursor.pos.z;
        if (char != ord("\n") && char != ord("\t")) {
            add_char_to_line(&chunk.lines[cursor.pos.y], cursor.pos.x++, from_ascii(char));
            cursor.last_valid_char_pos = cursor.pos.x;
            mark_dirty(chunk);
        } 
        elif (char == ord("\t")) {
            var space = from_ascii(ord(" "));
            for (var space_idx = 0; space_idx < spaces_to_indent; ++space_idx) {
                add_char_to_line(&chunk.lines[cursor.pos.y], cursor.pos.x++, space);
            }
            cursor.last_valid_char_pos = cursor.pos.x;
        }
        elif (char == ord("\n")) {
            handle_editor_key_down(VK_RETURN, false, false);     
        }
    }
}

// TODO(pragma): implement this like delete_selection()
// TODO(pragma): put the clipboard handling in a platfom layer we don't wanna depend on editor_win.prag
let paste_clipboard = fun(tab: panel_tab*) => void {
    var watermark = start_temp(&temp_memory_arena);
    
    var open_clipboard_result = Windows::OpenClipboard(window.handle);
    assert(open_clipboard_result != 0);
    
    var global_memory_handle = Windows::GetClipboardData(Windows::CF_TEXT);
    if (global_memory_handle != 0)
    {
        var global_memory_ptr = Windows::GlobalLock(global_memory_handle);
        assert(global_memory_ptr != nullptr);
        var char_count = strlen(global_memory_ptr);
        var clipboard = make_string(char_count@i32);
        memcpy(clipboard.data, global_memory_ptr, clipboard.length@mm);
        Windows::GlobalUnlock(global_memory_handle);
        
        paste_string(tab, clipboard);
        
    }
    Windows::CloseClipboard();
    stop_temp(&temp_memory_arena, watermark);
}

let add_char_to_line = fun(line_ptr: line*; char_pos: i32; char: character) => void {
    if (line_ptr.length + 1 < line_ptr.capacity) {
        for (var char_idx = line_ptr.length - 1; char_idx >= char_pos; --char_idx) {
            *(line_ptr.chars + (char_idx + 1)) = *(line_ptr.chars + char_idx);
        }
        line_ptr.length++;
        *(line_ptr.chars + char_pos) = char;
    }
}
let copy_to_clipboard = fun(tab: panel_tab*; copy_to_os_clipboard: bool) => void {
    var first: v3i;
    var last: v3i;
    get_ordered_selection_bounds(&tab.cursor, &first, &last);
    copy_to_clipboard(tab, first, last, copy_to_os_clipboard);
}

let copy_to_clipboard = fun(tab: panel_tab*; first: v3i; last: v3i; copy_to_os_clipboard: bool) => void {
    var document = tab.document;
    var cursor = &tab.cursor;
    
    if (cursor.clipboard.data != nullptr) {
        free(cursor.clipboard.data);
    }
    var watermark = start_temp(&temp_memory_arena);
    
    var char_ptr: i8* = nullptr;
    var char_count = 0;

    for (var z = first.z; z <= last.z; ++z) {
        var current_chunk = document.chunks + z;
        var y_from = 0;
        var y_to = current_chunk.lines.length - 1;
        if (z == first.z) {
            y_from = first.y;
        }
        if (z == last.z) {
            y_to = last.y;
        }
        for (var y = y_from; y <= y_to; ++y) {
            var current_line = current_chunk.lines[y];
            var first_x = 0;
            var last_x = current_line.length;
            if (z == first.z && y == first.y) {
                first_x = first.x;
            }
            if (z == last.z && y == last.y) {
                last_x = last.x;
            }
            for (var x = first_x; x < last_x; ++x) {
                char_ptr = push(&temp_memory_arena, 1);
                var chr = *(current_line.chars + x);
                *char_ptr = chr.value;
                char_count++;
            }
            if (z != last.z || y != last.y) {
                char_ptr = push(&temp_memory_arena, 1);
                *char_ptr = 13;
                char_count++;
                char_ptr = push(&temp_memory_arena, 1);
                *char_ptr = 10;
                char_count++;
            }
        }
    }
    if (char_count > 0) {
        cursor.clipboard.data = allocate(char_count@mm + 1);
        cursor.clipboard.length = char_count;
        var dest = cursor.clipboard.data;
        var src = char_ptr - (char_count - 1);
        memcpy(dest, src, (char_count@mm) * size_of(i8));
        
        // null terminate for windows clipboard handling
        cursor.clipboard[cursor.clipboard.length] = 0;
    } else {
        return;
    }
    
    // TODO(pragma): put the clipboard handling in a platfom layer we don't wanna depend on editor_win.prag
    if (copy_to_os_clipboard) {
        var error_code = Windows::OpenClipboard(window.handle);
        assert(error_code != 0);
        error_code = Windows::EmptyClipboard();
        assert(error_code != 0);
        
        var global_mem_handle = Windows::GlobalAlloc(Windows::GMEM_MOVEABLE, (char_count + 1)@mm);
        assert(global_mem_handle != 0);    
        
        var global_mem_ptr = Windows::GlobalLock(global_mem_handle);
        assert(global_mem_ptr != nullptr);
        memcpy(global_mem_ptr, cursor.clipboard.data, (char_count + 1)@mm);
        Windows::GlobalUnlock(global_mem_handle);
        
        var clipboard_data_result = Windows::SetClipboardData(Windows::CF_TEXT, global_mem_handle);
        assert(clipboard_data_result != 0);
        
        error_code = Windows::CloseClipboard();
        assert(error_code != 0);
    }
    
    stop_temp(&temp_memory_arena, watermark);
}

let cursor_up = fun(tab: panel_tab*; cursor: cursor*) => void {
    var document = tab.document;
    if (cursor.pos.y > 0) {
        cursor.pos.y--;
    } else {
        if (cursor.pos.z > 0) {
            // TODO what happens when we have a chunk that is completely empty?
            cursor.pos.z--;
            var chunk = document.chunks + cursor.pos.z;
            cursor.pos.y = chunk.lines.length - 1;
        }
    }
}

let cursor_down = fun(tab: panel_tab*; cursor: cursor*) => void {
    var document = tab.document;
    var chunk = document.chunks + cursor.pos.z;
    if (cursor.pos.y < chunk.lines.length - 1) {
        cursor.pos.y++;
    } else {
        if (cursor.pos.z < document.chunks_count - 1) {
            cursor.pos.z++;
            var chunk = document.chunks + cursor.pos.z;
            cursor.pos.y = 0;
        }
    }
}

let handle_next_word = fun(tab: panel_tab*) => void { 
    var document = tab.document;
    var cursor = &tab.cursor;
    var current_chunk = document.chunks + cursor.pos.z;
    var line = current_chunk.lines[cursor.pos.y];
    
    if (cursor.pos.x >= line.length) {
        return;
    }
    
    for (var char = *(line.chars + cursor.pos.x); cursor.pos.x < line.length && is_whitespace(char.value); cursor.pos.x++) { 
        char = *(line.chars + cursor.pos.x);
    }
    cursor.pos.x++;
    
    for (var char = *(line.chars + cursor.pos.x); cursor.pos.x < line.length; cursor.pos.x++) {
        char = *(line.chars + cursor.pos.x);
        if (!is_identifier_char(char.value)) {
            break;
        }
    }
}

let handle_prev_word = fun(tab: panel_tab*) => void { 
    var document = tab.document;
    var cursor = &tab.cursor;
    var current_chunk = document.chunks + cursor.pos.z;
    var line = current_chunk.lines[cursor.pos.y];
    
    if (cursor.pos.x == 0) {
        return;
    }
    cursor.pos.x--;
    for (var char = *(line.chars + cursor.pos.x); cursor.pos.x > 0 && is_whitespace(char.value); cursor.pos.x--) { 
        char = *(line.chars + cursor.pos.x);
    }
    var chr = *(line.chars + cursor.pos.x);
    if (is_identifier_char(chr.value)) {
        for (var char = *(line.chars + cursor.pos.x); cursor.pos.x > 0; cursor.pos.x--) {
            char = *(line.chars + cursor.pos.x);
            if (!is_identifier_char(char.value)) {
                cursor.pos.x++;
                break;
            }
        }
    }
}

let handle_delete = fun(tab: panel_tab*) => void {
    var document = tab.document;
    var cursor = &tab.cursor;
    var current_chunk = document.chunks + cursor.pos.z;
    var lines = current_chunk.lines;
    var lines_ptr = &current_chunk.lines;
    var current_line = current_chunk.lines[cursor.pos.y];
    var current_line_ptr = &current_chunk.lines[cursor.pos.y];
    
    if (cursor.pos.x < current_line.length) {
        for (var char_idx = cursor.pos.x; char_idx < current_line.length; ++char_idx) {
            if (char_idx == current_line.length - 1) {
                *(current_line.chars + char_idx) = from_ascii(0);
            } else {
                *(current_line.chars + char_idx) = *(current_line.chars + (char_idx + 1));
            }
        }
        mark_dirty(current_chunk);
        current_line_ptr.length--;
    } else {
        var next_line: line;
        var next_line_chunk_idx: i32;
        var next_line_idx: i32;
        if (cursor.pos.y == lines.length - 1) {
            if (cursor.pos.z + 1 == document.chunks_count) {
                return;
            }
            next_line_chunk_idx = cursor.pos.z + 1;
            var chunk = document.chunks + (cursor.pos.z + 1);
            assert(chunk.lines.length > 0);
            next_line_idx = 0;
            next_line = chunk.lines[0];
            mark_dirty(chunk);
        } else {
            next_line_chunk_idx = cursor.pos.z;
            next_line_idx = cursor.pos.y + 1;
            next_line = lines[cursor.pos.y + 1];
        }
        for (var char_idx = 0; char_idx < next_line.length; ++char_idx) {
            *(current_line.chars + (cursor.pos.x + char_idx)) = *(next_line.chars + char_idx);
        }
        current_line_ptr.length += next_line.length;
        mark_dirty(current_chunk);
        delete_line(document, next_line_chunk_idx, next_line_idx);
    }
}

let handle_backspace = fun(tab: panel_tab*) => void {
    var document = tab.document;
    var cursor = &tab.cursor;
    var current_chunk = document.chunks + cursor.pos.z;
    var lines = current_chunk.lines;
    var lines_ptr = &current_chunk.lines;
    var current_line = current_chunk.lines[cursor.pos.y];
    var current_line_ptr = &current_chunk.lines[cursor.pos.y];
    
    if (cursor.pos.x > 0) {
        current_line_ptr.length--;
        for (var char_idx = cursor.pos.x - 1; char_idx < current_line.length - 1; ++char_idx) {
            *(current_line.chars + char_idx) = *(current_line.chars + (char_idx + 1));
        }
        *(current_line.chars + current_line_ptr.length) = from_ascii(0);
        cursor.pos.x--;
    } else {
        var dest_line: line;
        var dest_line_ptr: line*;
        if (cursor.pos.y == 0 && cursor.pos.z == 0) {
            return;
        }
        if (cursor.pos.y > 0) {
            dest_line = lines[cursor.pos.y - 1];
            dest_line_ptr = &lines[cursor.pos.y - 1];
        } else {
            assert(cursor.pos.y == 0);
            assert(cursor.pos.z > 0);
            var prev_chunk = document.chunks + (cursor.pos.z - 1);
            assert(prev_chunk.lines.length > 0);
            dest_line = prev_chunk.lines[prev_chunk.lines.length - 1];
            dest_line_ptr = &prev_chunk.lines[prev_chunk.lines.length - 1];
            mark_dirty(prev_chunk);
        }
        cursor.pos.x = dest_line.length;
        var src_line = lines[cursor.pos.y];
        for (var char_idx = 0; char_idx < src_line.length; ++char_idx) {
            *(dest_line.chars + (dest_line.length + char_idx)) = *(src_line.chars + char_idx);
            *(src_line.chars + char_idx) = from_ascii(0);
        }
        cursor.pos.x = dest_line_ptr.length;
        dest_line_ptr.length += src_line.length;
        assert(dest_line_ptr.length < max_line_length);
        
        var delete_line_idx = cursor.pos.y;
        delete_line(document, cursor.pos.z, delete_line_idx, true);
        cursor_up(tab, cursor);
        
    }
    cursor.last_valid_char_pos = cursor.pos.x;
    mark_dirty(current_chunk);
}

let syntax_highlight = fun(document: document*) => void {
    var t0 = get_perf_counter();
    for (var chunk_idx = 0; chunk_idx < document.chunks_count; ++chunk_idx) {
        var chunk = document.chunks + chunk_idx;
        if (chunk.needs_syntax_highlight) {
            for (var line_idx = 0; line_idx < chunk.lines.length; ++line_idx) {
                tokenize(chunk.lines.data + line_idx);
            }
            chunk.needs_syntax_highlight = false;
        }
    }
    var t1 = get_perf_counter();
    // debug_print("syntax_highlight time [ms]", get_ms_elapsed(t0, t1));
}

let mark_dirty = fun(chunk: text_chunk*) => void {
    chunk.needs_syntax_highlight = true;
    chunk.is_dirty_for_undo = true;
}
let free_undo_point = fun(up: undo_point*) => void {
    for (var uc_idx = 0; uc_idx < up.dirty_chunks.length; ++uc_idx) {
        free_chunk(&up.dirty_chunks[uc_idx].data);
    }
    free(up.dirty_chunks.data@ptr);
}
let add_undo_point = fun(editor_state: editor_state*; tab: panel_tab*) => void {
    var up = undo_point { };
    up.active_panel = editor_state.active_panel;
    up.active_tab = editor_state.active_panel.active_tab;
    up.tab_data = *up.active_tab;
    var doc = up.active_tab.document;
    up.document_chunks_count = doc.chunks_count;
    var dirty_chunk_count = 0;
    for (var chunk_idx = 0; chunk_idx < doc.chunks_count; ++chunk_idx) {
        var chunk = doc.chunks + chunk_idx;
        if (chunk.is_dirty_for_undo) {
            dirty_chunk_count++;
        }
    }
    if (dirty_chunk_count > 0) {
        up.dirty_chunks.length = dirty_chunk_count;
        up.dirty_chunks.data = allocate(size_of(undo_chunk) * dirty_chunk_count@mm)@undo_chunk*;
        var dirty_chunk_idx = 0;
        for (var chunk_idx = 0; chunk_idx < doc.chunks_count; ++chunk_idx) {
            var chunk = doc.chunks + chunk_idx;
            if (chunk.is_dirty_for_undo) {
                var uc = undo_chunk { };
                uc.idx = chunk_idx;
                uc.data = clone_text_chunk(chunk);
                up.dirty_chunks[dirty_chunk_idx++] = uc;
                chunk.is_dirty_for_undo = false;
            }
        }
        if (editor_state.undo_pos + 1 < max_undo_points) {
            if (editor_state.undo_points.length >= editor_state.undo_pos + 1) {
                for (var idx = editor_state.undo_pos; idx < editor_state.undo_points.length; ++idx) {
                    free_undo_point(&editor_state.undo_points[idx]);
                }
                editor_state.undo_points.length = editor_state.undo_pos + 1;
            } else {
                editor_state.undo_points.length++;
                assert(editor_state.undo_points.length == editor_state.undo_pos + 1);
            }
            editor_state.undo_points[editor_state.undo_pos] = up;
            editor_state.undo_pos++;
            // debug_print("undo_pos", editor_state.undo_pos);
        }
    }
    editor_state.dirty_for_undo = false;
}

let restore_undo_point = fun(editor_state: editor_state*; up: undo_point*) => void {
    editor_state.dirty_for_undo = false;
    editor_state.active_panel = up.active_panel;
    editor_state.active_panel.active_tab = up.active_tab;
    *editor_state.active_panel.active_tab = up.tab_data;
    
    var temp_up = up;
    var temp_tab = editor_state.active_panel.active_tab;
    
    var doc = up.tab_data.document;
    doc.chunks_count = up.document_chunks_count;
    assert(up.document_chunks_count > 0);
    while(doc.chunks_count > up.document_chunks_count) {
        doc.chunks_count--;
        free_chunk(doc.chunks + doc.chunks_count);
    }
    for (var uc_idx = 0; uc_idx < up.dirty_chunks.length; ++uc_idx) {
        var uc = &up.dirty_chunks[uc_idx];
        assert(uc.idx >= 0 && uc.idx < up.document_chunks_count);
        free_chunk(doc.chunks + uc.idx);
        var cloned_chunk = clone_text_chunk(&uc.data);
        cloned_chunk.is_dirty_for_undo = false;
        *(doc.chunks + uc.idx) = cloned_chunk;
    }
}

let undo = fun(editor_state: editor_state*) => void {
    if (editor_state.undo_pos <= 1) {
        return;
    }
    editor_state.undo_pos--;
    
    var up = &editor_state.undo_points[editor_state.undo_pos - 1];
    restore_undo_point(editor_state, up);
    editor_state.dirty_for_undo = false;
}

let redo = fun(editor_state: editor_state*) => void {
    if (editor_state.undo_pos >= editor_state.undo_points.length) {
        return;
    }
    editor_state.undo_pos++;
    var up = &editor_state.undo_points[editor_state.undo_pos - 1];
    // debug_print("redo", editor_state.undo_pos);
    restore_undo_point(editor_state, up);
    editor_state.dirty_for_undo = false;
}

let clamp_cursor = fun(tab: panel_tab*) => void {
    var document = tab.document;
    var cursor = &tab.cursor;
    cursor.pos.z = Math::clamp(cursor.pos.z, 0, document.chunks_count - 1);
    var current_chunk = document.chunks + cursor.pos.z;
    var lines = current_chunk.lines;
    cursor.pos.y = Math::clamp(cursor.pos.y, 0, current_chunk.lines.length - 1);
    cursor.pos.x = Math::clamp(cursor.pos.x, 0, lines[cursor.pos.y].length);
}

let handle_search_key_down = fun(vk_code: i32) => void {
    var char_word: i16 = 0;
    GetKeyboardState(editor_state.keyboard_state);
    ToAscii(vk_code, vk_code, editor_state.keyboard_state, &char_word, 0);
    char_word = 0xFF & char_word;
    var char = from_ascii(char_word@i8);
    
    if (is_printable(char.value@i8)) {
    }
}

let handle_console_key_down = fun(vk_code: i32; console: editor_panel*) => void {
}


let register_text_panel_commands = fun() => void {
    
}

let handle_text_panel_key_down = fun(vk_code: i32; active_panel: editor_panel*; should_syntax_highlight: bool; 
                                     should_auto_indent: bool) => void {
    var active_tab = active_panel.active_tab;
    if (active_tab@ptr == nullptr) {
        return;
    }
    var document = active_tab.document;
    var cursor = &active_tab.cursor;
    var old_cursor_pos = cursor.pos;
    var current_chunk = document.chunks + cursor.pos.z;
    var lines = current_chunk.lines;
    var lines_ptr = &current_chunk.lines;
    var current_line = lines[cursor.pos.y];
    var current_line_ptr = &lines[cursor.pos.y];
    
    assert(current_line.length >= 0 && current_line.length < max_line_length);
    assert(cursor.pos.x <= current_line.length);
    assert(cursor.pos.y < lines.length);
    assert(lines.length <= text_chunk_line_count);
    assert(lines.length > 0);
    
    var old_editor_dirty_for_undo = editor_state.dirty_for_undo;
    
    // TODO(pragma): this could be more finegrain
    editor_state.dirty_for_undo = true;
    
    var char_word: i16 = 0;
    GetKeyboardState(editor_state.keyboard_state);
    ToAscii(vk_code, vk_code, editor_state.keyboard_state, &char_word, 0);
    char_word = 0xFF & char_word;
    var char = from_ascii(char_word@i8);
    
    var should_clear_selection = true;
    var supress_new_selection = false;
    
    if (is_printable(char.value@i8)) {
        if (cursor.selection_active) {
            delete_selection(active_tab);
            current_chunk = document.chunks + cursor.pos.z;
            lines = current_chunk.lines;
            lines_ptr = &current_chunk.lines;
            current_line = lines[cursor.pos.y];
            current_line_ptr = &lines[cursor.pos.y];
        }
        if (should_auto_indent && char.value == ord("}")) {
            if (left_is_whitespace(current_line_ptr, cursor.pos.x)) {
                for (var back_idx = 0; back_idx < spaces_to_indent; ++back_idx) {
                    handle_backspace(active_tab);
                }    
            }
        }
        add_char_to_line(current_line_ptr, cursor.pos.x++, char);
        cursor.last_valid_char_pos = cursor.pos.x;
        if (current_line_ptr.length < max_line_length) {
            *(current_line.chars + current_line_ptr.length) = character { 0 };
        }
        mark_dirty(current_chunk);
    }
    elif (vk_code == VK_BACK) {
        if (cursor.selection_active) {
            delete_selection(active_tab);
            cursor.last_valid_char_pos = cursor.pos.x;
        } else {
            if (left_is_whitespace(current_line_ptr, cursor.pos.x) && cursor.pos.x >= spaces_to_indent) {
                // TODO(pragma): this is not quite correct we want to snap to multiples of spaces_to_indent
                for (var indent_idx = 0; indent_idx < spaces_to_indent; ++indent_idx) {
                    handle_backspace(active_tab);
                }
            } else {
                handle_backspace(active_tab);
            }
        }
    }
    elif (vk_code == VK_TAB && !editor_state.control_pressed) {
        supress_new_selection = true;
        // TODO(pragma): fix selection start not moving with indent/dedent
        if (cursor.selection_active) {
            var dedent = editor_state.shift_pressed;
            var temp_line_length = current_line_ptr.length;
            change_indent_selection(active_tab, dedent);
            var delta = current_line_ptr.length - temp_line_length;
            cursor.pos.x = Math::max(0, cursor.pos.x + delta);
            cursor.last_valid_char_pos = cursor.pos.x;
            should_clear_selection = false;
        } else {
            if (!editor_state.shift_pressed) {
                indent_line(current_line_ptr, cursor.pos.x);
                cursor.pos.x += spaces_to_indent;
                cursor.last_valid_char_pos = cursor.pos.x;
                mark_dirty(current_chunk);
            } else {
                dedent_line(current_line_ptr);
                cursor.pos.x = Math::max(0, cursor.pos.x - spaces_to_indent);
                cursor.last_valid_char_pos = cursor.pos.x;
                mark_dirty(current_chunk);
            }
        }
    }
    elif (vk_code == VK_DELETE) {
        if (cursor.selection_active) {
            delete_selection(active_tab);
            cursor.last_valid_char_pos = cursor.pos.x;
        } else {
            handle_delete(active_tab);
        }
    }
    elif (vk_code == VK_RETURN) {
        if (cursor.selection_active) {
            delete_selection(active_tab);
            current_chunk = document.chunks + cursor.pos.z;
            lines = current_chunk.lines;
            lines_ptr = &current_chunk.lines;
            current_line = lines[cursor.pos.y];
            current_line_ptr = &lines[cursor.pos.y];
        }
        cursor.pos.y++;
        if (cursor.pos.y >= text_chunk_line_count) {
            cursor.pos.y = 0;
            cursor.pos.z++;
        }
        var next_pos_x = insert_line(document, cursor.pos.z, cursor.pos.y, current_line_ptr, cursor.pos.x, should_auto_indent);
        
        assert(cursor.pos.z < document.chunks_count);
        current_line_ptr.length = cursor.pos.x;
        cursor.pos.x = next_pos_x;
        cursor.last_valid_char_pos = cursor.pos.x;
    }
    elif (vk_code == VK_SHIFT) {
        editor_state.shift_pressed = true;
        should_clear_selection = false;
    }
    elif (vk_code == VK_CONTROL) {
        editor_state.control_pressed = true;
        should_clear_selection = false;
    }
    elif (vk_code == VK_LEFT) {
        if (cursor.pos.x > 0) {
            if (editor_state.control_pressed) {
                handle_prev_word(active_tab);
            } else {
                cursor.pos.x--;    
            }
        } else {
            cursor_up(active_tab, cursor);
            var chunk = document.chunks + cursor.pos.z;
            cursor.pos.x = chunk.lines.length - 1;
        }
        cursor.last_valid_char_pos = cursor.pos.x;
    }
    elif (vk_code == VK_RIGHT) {
        if (cursor.pos.x < current_line.length) {
            if (editor_state.control_pressed) {
                handle_next_word(active_tab);
            } else {
                cursor.pos.x++;    
            }
        } else {
            cursor_down(active_tab, cursor);
            cursor.pos.x = 0;
        }
        cursor.last_valid_char_pos = cursor.pos.x;
    }
    elif (vk_code == VK_UP) {
        if (editor_state.control_pressed) {
            scroll_lines(active_panel, &editor_state.global_render_state, -1);
            should_clear_selection = false;
        } else {
            cursor_up(active_tab, cursor);
            if (!cursor.selection_active && editor_state.shift_pressed) {
                cursor.last_valid_char_pos = cursor.pos.x;
            }
        }
    }
    elif (vk_code == VK_DOWN) {
        if (editor_state.control_pressed) {
            scroll_lines(active_panel, &editor_state.global_render_state, +1);
            should_clear_selection = false;
        } else {
            cursor_down(active_tab, cursor);
            if (!cursor.selection_active && editor_state.shift_pressed) {
                cursor.last_valid_char_pos = cursor.pos.x;
            }
        }
    }
    elif (vk_code == VK_END) {
        if (!editor_state.control_pressed) {
            cursor.last_valid_char_pos = current_line.length;
        } else {
            cursor.pos.z = document.chunks_count - 1;
            var chunk = document.chunks + (document.chunks_count - 1);
            cursor.pos.y =  chunk.lines.length - 1;
            cursor.last_valid_char_pos = chunk.lines[cursor.pos.z].length;
        }
    }
    elif (vk_code == VK_HOME) {
        if (!editor_state.control_pressed) {
            var current_indent = get_line_indent(current_line_ptr);
            if (cursor.pos.x <= current_indent) {
                cursor.last_valid_char_pos = 0;    
            } else {
                cursor.last_valid_char_pos = current_indent;    
            }
        } else {
            cursor.pos.z = 0;
            cursor.pos.y =  0;
            cursor.last_valid_char_pos = 0;
        }
    }
    elif (vk_code == VK_PRIOR) {
        var delta = active_panel.visible_line_count - 2;
        if (delta <= 0) {
            delta = 1;
        }
        if (cursor.pos.y - delta >= 0) {
            cursor.pos.y -= delta;
        } else {
            delta -= cursor.pos.y;
            while (true) {
                if (cursor.pos.z > 0) {
                    cursor.pos.z--;
                    var chunk = document.chunks + cursor.pos.z;
                    var py = chunk.lines.length - 1;
                    if (py - delta >= 0) {
                        cursor.pos.y = py - delta;
                        break;
                    } else {
                        delta -= py;
                    }
                } else {
                    cursor.pos.y = 0;
                    break;
                }
            }
        }
    }
    elif (vk_code == VK_NEXT) {
        var delta = active_panel.visible_line_count - 2;
        if (delta <= 0) {
            delta = 1;
        }
        if (cursor.pos.y + delta <= lines.length - 1) {
            cursor.pos.y += delta;
        } else {
            delta -= (lines.length - 1) - cursor.pos.y;
            while (true) {
                if (cursor.pos.z < document.chunks_count - 1) {
                    cursor.pos.z++;
                    var chunk = document.chunks + cursor.pos.z;
                    var ll = chunk.lines.length;
                    if (delta <= ll - 1) {
                        cursor.pos.y = delta;
                        break;
                    } else {
                        delta -= (ll - 1);
                    }
                } else {
                    var chunk = document.chunks + cursor.pos.z;
                    var ll = chunk.lines.length;
                    cursor.pos.y = ll - 1;
                    break;
                }
            }
        }
    }
    elif (editor_state.control_pressed && vk_code == ord("C")@i32) {
        copy_to_clipboard(active_tab, true);
        should_clear_selection = false;
    }
    elif (editor_state.control_pressed &&  vk_code == ord("V")@i32) {
        if (cursor.selection_active) {
            delete_selection(active_tab);
        }
        paste_clipboard(active_tab);
        cursor.last_valid_char_pos = cursor.pos.x;
        
    }
    elif (editor_state.control_pressed && vk_code == 107) {
        editor_state.global_render_state.target_font_size *= 1.2;
    }
    elif (editor_state.control_pressed && vk_code == 109) {
        editor_state.global_render_state.target_font_size /= 1.2;
    }
    elif (editor_state.control_pressed && vk_code == ord("X")@i32) {
        var line_idx = cursor.pos.y;
        var should_decrement_line_count = !(cursor.pos.z == 0 && document.chunks_count == 1 && current_chunk.lines.length == 1);
        
        delete_line(document, cursor.pos.z, line_idx, should_decrement_line_count);
        
        if (cursor.pos.z >= document.chunks_count) {
            assert(cursor.pos.y == 0);
            cursor_up(active_tab, &active_tab.cursor);
        }
        if (cursor.pos.y >= current_chunk.lines.length && cursor.pos.z + 1 < document.chunks_count) {
            cursor_down(active_tab, &active_tab.cursor);
        }
    }
    elif (editor_state.control_pressed && vk_code == ord("A")@i32) {
        active_tab.cursor.selection_start = v3iz;
        cursor.pos.z = document.chunks_count - 1;
        var chunk = document.chunks + (document.chunks_count - 1);
        cursor.pos.y =  chunk.lines.length - 1;
        cursor.last_valid_char_pos = chunk.lines[cursor.pos.y].length;
        active_tab.cursor.selection_active = true;
        should_clear_selection = false;
    }
    elif (editor_state.control_pressed && vk_code == ord("S")@i32) {
        if (save_text_file(active_tab)) {
            editor_state.global_render_state.color_scale = 2.0;    
        }
    }
    elif (editor_state.control_pressed && vk_code == ord("1")@i32) {
        add_undo_point(&editor_state, active_tab);
        editor_state.active_panel = &editor_state.left_panel;
        if (editor_state.active_panel.active_tab@ptr != nullptr) {
            clamp_cursor(editor_state.active_panel.active_tab);
        }
    }
    elif (editor_state.control_pressed && vk_code == ord("2")@i32) {
        add_undo_point(&editor_state, active_tab);
        editor_state.active_panel = &editor_state.right_panel;
        if (editor_state.active_panel.active_tab@ptr != nullptr) {
            clamp_cursor(editor_state.active_panel.active_tab);    
        }
    }
    elif (editor_state.control_pressed && vk_code == ord("N")@i32){
        add_undo_point(&editor_state, active_tab);
        if (active_panel.tabs.length < active_panel.tabs_capacity) {
            if (editor_state.documents.length < editor_state.documents_capacity) {
                var doc_idx = editor_state.documents.length++;
                editor_state.documents[doc_idx] = create_document(doc_idx);
                var tab_idx = active_panel.tabs.length++;
                active_panel.tabs[tab_idx] = create_tab(tab_idx, &editor_state.documents[editor_state.documents.length - 1]);
                active_panel.active_tab = &active_panel.tabs[active_panel.tabs.length - 1];
            }
        }
    }
    elif (editor_state.control_pressed && vk_code == VK_TAB) {
        add_undo_point(&editor_state, active_tab);
        if (active_panel.tabs.length > 0) {
            active_panel.active_tab = &active_panel.tabs[(active_tab.idx + 1) % active_panel.tabs.length];
        }
    }
    elif (editor_state.control_pressed && vk_code == ord("Z")@i32) {
        if (editor_state.shift_pressed) {
            redo(&editor_state);
            supress_new_selection = true;
        } else {
            if (old_editor_dirty_for_undo) {
                add_undo_point(&editor_state, active_tab);
            }
            undo(&editor_state);
            supress_new_selection = true;
        }
    }
    else {
        should_clear_selection = false;
    }
    
    if (should_syntax_highlight) {
        syntax_highlight(document);
    }
        
    current_chunk = document.chunks + cursor.pos.z;
    lines = current_chunk.lines;
    cursor.pos.y = Math::clamp(cursor.pos.y, 0, current_chunk.lines.length - 1);
    cursor.pos.x = Math::clamp(cursor.last_valid_char_pos, 0, lines[cursor.pos.y].length);
    
    var has_cursor_moved = !equal(active_tab.cursor.pos, old_cursor_pos);
    active_tab.cursor.should_scroll_to_cursor = has_cursor_moved;
    if (has_cursor_moved) {
        reset_cursor_blink();
    }
    var old_cursor_pos_valid = old_cursor_pos.y < lines.length && old_cursor_pos.x <= lines[old_cursor_pos.y].length;
    if (!supress_new_selection)
    {
        if (!is_printable(char.value@i8) && editor_state.shift_pressed && !cursor.selection_active && has_cursor_moved && old_cursor_pos_valid) {
            cursor.selection_active = true;
            cursor.selection_start = old_cursor_pos;
        }    
    }
    if (!editor_state.shift_pressed && should_clear_selection) {
        active_tab.cursor.selection_active = false;
    }
#if DEBUG
    lines_ptr = &current_chunk.lines;
    current_line_ptr = &lines[cursor.pos.y];
    assert(current_line_ptr.length >= 0 && current_line_ptr.length < max_line_length);
    assert(cursor.pos.x <= current_line_ptr.length);
    assert(cursor.pos.y < lines_ptr.length);
    assert(lines_ptr.length <= text_chunk_line_count);
#endif
}

let handle_editor_key_down = fun(vk_code: i32; should_syntax_highlight: bool; should_auto_indent: bool) => void {
    editor_state.last_keypress_time = editor_state.global_render_state.time;
    var active_panel = editor_state.active_panel;
    if (active_panel == &editor_state.console_panel) {
        handle_console_key_down(vk_code, active_panel);
        return;
    } else {
        handle_text_panel_key_down(vk_code, active_panel, should_syntax_highlight, should_auto_indent);
    }
}

let handle_editor_key_up = fun(vk_code: i32) => void {
    // debug_print("key_up", vk_code);
    if (vk_code == VK_SHIFT) {
        editor_state.shift_pressed = false;
    }
    elif (vk_code == VK_CONTROL) {
        editor_state.control_pressed = false;
    }
}

let add_document = fun(editor_state: editor_state*) => document* {
    var result: document* = nullptr@document*;
    if (editor_state.documents.length < editor_state.documents_capacity) {
        var idx = editor_state.documents.length++;
        result = &editor_state.documents[idx];
        *result = create_document(idx);
    }
    return result;
}


let add_tab = fun(panel: editor_panel*; document: document*) => panel_tab* {
    var result: panel_tab* = nullptr@panel_tab*;
    if (panel.tabs.length < panel.tabs_capacity) {
        var idx = panel.tabs.length++;
        result = &panel.tabs[idx];
        *result = create_tab(idx, document);
        panel.active_tab = result;
    }
    return result;
}

let load_text_file = fun(tab: panel_tab*; file_name: string) => void {
    var temp_file_name = file_name;
    var document = tab.document;
    var watermark = start_temp(&temp_memory_arena);
    var txt = read_file(file_name);
    if (txt.length > 0) {
        paste_string(tab, txt);
        document.file_name = file_name;
    } else {
        debug_print("could not load text file with argument", file_name);
    }
    syntax_highlight(document);
    tab.cursor.pos = v3iz;
    stop_temp(&temp_memory_arena, watermark);
}

let load_all_files_in_directory = fun(editor_state: editor_state*; dir: string) => void {
    var data = WIN32_FIND_DATA {};
    var wc = concat(dir[:-1], "*.prag\0");
    var handle = Windows::FindFirstFileA(cstr(wc), &data);
    if (handle != Windows::INVALID_HANDLE_VALUE) {
        while (true) {
            var file_name = clone_string(concat(dir[:-1], from_cstr(&data.FileName[0], 260)));
            debug_print("filename", file_name);
            var doc = add_document(editor_state);
            var left_tab = add_tab(&editor_state.left_panel, doc);
            load_text_file(left_tab, file_name);
            var right_tab = add_tab(&editor_state.right_panel, doc);
            left_tab.cursor.pos = v3iz;
            right_tab.cursor.pos = v3iz;
            syntax_highlight(doc);
            if (Windows::FindNextFileA(handle, &data) == 0) {
                break;
            }
        }
    }
}

let save_text_file = fun(tab: panel_tab*) => bool {
    var document = tab.document;
    if (document.file_name.length > 0) {
        var first = v3iz;
        var last: v3i;
        last.z = document.chunks_count - 1;
        var chunk = document.chunks + (document.chunks_count - 1);
        last.y =  chunk.lines.length - 1;
        last.x = chunk.lines[last.y].length;
        copy_to_clipboard(tab, first, last, false);
        write_file(document.file_name, tab.cursor.clipboard);
        // editor_state.render_state.color_scale = 2.0;
        return true;
    }
    return false;
}

var frames = 0;
let render = fun(editor_state: editor_state*; window_state: window_state*) => void {
    var t0 = get_perf_counter();
    var time = get_seconds_elapsed(editor_state.start_time_ticks, t0);
    var render_state = &editor_state.global_render_state;
    render_state.delta_time = time@f32 - render_state.time;
    render_state.time = time@f32;
    render_opengl(window_state.client_width, window_state.client_height, editor_state, window_state.dc);
    var t1 = get_perf_counter();
    if (editor_state.dirty_for_undo && render_state.time - editor_state.last_keypress_time > 0.1) {
        add_undo_point(editor_state, editor_state.active_panel.active_tab);
    }
    // frames++;
    // if (frames == 600) {
    //     debug_print("ms elapsed: ", get_seconds_elapsed(t0, t1) * 1000.0);
    //     frames = 0;
    // }
}
