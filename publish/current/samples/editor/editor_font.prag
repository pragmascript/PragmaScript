import "../preamble.prag"
import "../vec.prag"
import "../opengl/opengl.prag"
import "../xml.prag"


import "editor.prag"
import "editor_opengl.prag"

let glyph = struct(
    id: i8;
    x_offset: i32;
    y_offset: i32;
    x_advance: i32;
    pos_x: i32;
    pos_y: i32;
    width: i32;
    height: i32;
);


let font = struct (
    texture_handle: i32;
    v_bo: i32;
    e_bo: i32;
    uv_bo: i32;
    color_bo: i32;
    background_color_bo: i32;
    
    atlas_width: i32;
    atlas_height: i32;
    base_size: i32;
    line_height: i32;
    
    glyphs: glyph[];
    
    kerning_table: i32[];
);

let load_font = fun() => font {
    var result = font { };
    
    result.texture_handle = load_texture("fonts/plex_mono.bmp\0", &result.atlas_width, &result.atlas_height);
    glGenBuffers(1, &result.v_bo);
    glGenBuffers(1, &result.e_bo);
    glGenBuffers(1, &result.uv_bo);
    glGenBuffers(1, &result.color_bo);
    glGenBuffers(1, &result.background_color_bo);
    
    let glyph_count = 256;
    
    result.glyphs.data = push(&temp_memory_arena, size_of(glyph) * glyph_count@mm)@glyph*;
    result.glyphs.length = glyph_count;
    
    for (var i = 0; i < glyph_count; ++i) {
        result.glyphs[i] = glyph { };
    }
    var xml = read_xml("fonts/plex_mono.png.fnt\0");
    var e_font = get_child(&xml, "font");
    assert(e_font@ptr != nullptr);
    from_str(get_attrib_value(get_child(e_font, "info"), "size"), &result.base_size);
    from_str(get_attrib_value(get_child(e_font, "common"), "lineHeight"), &result.base_size);
    
    var e_chars = get_child(e_font, "chars");
    for (var char_idx = 0; char_idx < e_chars.childs.count; char_idx++) {
        var e_char = e_chars.childs.data + char_idx;
        var glyph = glyph { };
        var id_32 = 0;
        from_str(get_attrib_value(e_char, "id"), &id_32);
        assert(id_32 >= 0 && id_32 < glyph_count);
        glyph.id = id_32@i8;
        from_str(get_attrib_value(e_char, "xoffset"), &glyph.x_offset);
        from_str(get_attrib_value(e_char, "yoffset"), &glyph.y_offset);
        from_str(get_attrib_value(e_char, "xadvance"), &glyph.x_advance);
        from_str(get_attrib_value(e_char, "x"), &glyph.pos_x);
        from_str(get_attrib_value(e_char, "y"), &glyph.pos_y);
        from_str(get_attrib_value(e_char, "width"), &glyph.width);
        from_str(get_attrib_value(e_char, "height"), &glyph.height);
        result.glyphs[id_32] = glyph;
    }
    
    var kerning_count: i32;
    from_str(get_attrib_value(get_child(e_font, "kernings"), "count"), &kerning_count);
    if (kerning_count == 0) {
        
        //TODO(pragma): what does this do?
        // var test = AddFontResourceA(cstr("fonts\\TheanoDidot-Regular.ttf\0"));
        
#if false
        var font_handle = CreateFontA(result.base_size, 0, 0, 0,
                                      FW_NORMAL,
                                      0,
                                      0,
                                      0,
                                      DEFAULT_CHARSET,
                                      OUT_DEFAULT_PRECIS,
                                      CLIP_DEFAULT_PRECIS,
                                      ANTIALIASED_QUALITY,
                                      DEFAULT_PITCH|FF_DONTCARE,
                                      cstr("IBM Plex Mono\0"));
        assert(font_handle != Windows::INVALID_HANDLE_VALUE);
        var font_dc = CreateCompatibleDC(GetDC(0));
        SelectObject(font_dc, font_handle);
        var kerning_pair_count = GetKerningPairsA(font_dc, 0, nullptr@KERNINGPAIR*);
        
        var kerning_pairs = @KERNINGPAIR* allocate(size_of(KERNINGPAIR) * kerning_pair_count@mm);
        GetKerningPairsA(font_dc, kerning_pair_count, kerning_pairs);
#endif        
        result.kerning_table.data = @i32* push(&temp_memory_arena, @mm (glyph_count*glyph_count) * size_of(i32));
        result.kerning_table.length = glyph_count*glyph_count;
        memset(result.kerning_table.data@ptr, 0, result.kerning_table.length@mm);

#if false      
        for (var kerning_pair_idx = 0; kerning_pair_idx < kerning_pair_count; kerning_pair_idx++) {
            var kp = kerning_pairs + kerning_pair_idx;
            var idx = @i32 kp.wSecond * glyph_count + kp.wFirst@i32;
            result.kerning_table[idx] = kp.iKernAmount;
        }
        free(kerning_pairs@ptr);
#endif        
    }
    return result;
}


let map_to_gl = fun(p: v3; width: i32; height: i32) => v3 {
    var result = v3(
        2.0 * (p.x / (width@f32 - 1.0)) - 1.0,
        2.0 * (p.y / (height@f32 - 1.0)) - 1.0,
        p.z
    );
    return result;
}

let get_kerning_pair = fun(font: font*; first: i8; second: i8) => i32 {
    var idx = @i32 second * font.glyphs.length + first@i32;
    return font.kerning_table[idx];
}
let char_alignment = enum( 
    left;
    right;
);


let text_render_context = struct(
    font: font*;
    relative_size: f32;
    foreground_color: v3;
    background_color: v3;
    background_color_selected: v3;
    alignment: char_alignment;
    quads: mesh*;
    render_width: i32;
    render_height: i32;
);

let add_character = fun(char: character; char_next: character; selected: bool; p: v2*;
                        @text_render_context: text_render_context*) => void {
    var glyph = &font.glyphs[char.value@i32];
    var w = font.atlas_width@f32 - 1.0;
    var h = font.atlas_height@f32 - 1.0;
    var uv0 = v2(glyph.pos_x@f32 / w, 1.0 - glyph.pos_y@f32 / h);
    var uv1 = v2(
        @f32 (glyph.pos_x + glyph.width) / w,
        1.0 - @f32 (glyph.pos_y + glyph.height) / h
    );
    var p_size = v2(relative_size * glyph.width@f32, relative_size * glyph.height@f32);
    var size = v2(2*p_size.x / (render_width - 1)@f32, 2*p_size.y / (render_height - 1)@f32);

    var current_p = *p;
    
    var first: character;
    var second: character;
    var dir: f32;
    if (alignment == char_alignment::left) {
        first = char;
        second = char_next;
        dir = 1.0;
    }
    elif (alignment == char_alignment::right) {
        first = char_next;
        second = char;
        dir = -1.0;
    }
    p.x += dir * relative_size * glyph.x_advance@f32;
    if (alignment == char_alignment::right) {
        current_p = *p;
    }
    
    var pos = add(v3(current_p.x, current_p.y, 0), v3(relative_size * glyph.x_offset@f32, -relative_size *  glyph.y_offset@f32, 0));
    pos = map_to_gl(v3(pos.x, pos.y, 0), render_width, render_height);
    
    if (char_next.value != 0) {
        var kerning = get_kerning_pair(font, first.value, second.value);
        p.x += dir * relative_size * kerning@f32;
    }
    if (selected) {
        var start_pos = map_to_gl(v3(current_p.x, current_p.y, 0), render_width, render_height);
        var end_pos = map_to_gl(v3(p.x, p.y, 0), render_width, render_height);
        var line_height = (relative_size * font.base_size@f32) / (render_height - 1)@f32;
        var size = v2(end_pos.x - start_pos.x, 2*line_height); 
        var c = v4 { background_color_selected.x, background_color_selected.y, background_color_selected.z, 1.0 };
        add_quad(quads, start_pos, size, uv0, uv1, c, foreground_color);
    }
    if (char.value != ord(" ") && char.value != ord("\n")) {
        var c = v4 { foreground_color.x, foreground_color.y, foreground_color.z, 0.0 };
        var bc = background_color;
        if (selected) {
            bc = background_color_selected;
        }
        add_quad(quads, pos, size, uv0, uv1, c, bc);
    }
}

let render_text = fun(editor_state: editor_state*; font: font*; font_size: f32) => void {
    var render_state = &editor_state.render_state;
    
    
    var cursor = &editor_state.cursor;
    var relative_size = font_size / font.base_size@f32;
    
    var quads = mesh { };
    let max_chars = max_line_length * text_chunk_line_count;
    
    let regular_font_color = v3(0.831, 0.831, 0.788);
    let line_font_color = scaled(regular_font_color, 0.3);
    let cursor_font_color = regular_font_color;
    
    
    var random_colors = [
        v3(1.0, 0.0, 0.0),
        v3(0.0, 1.0, 0.0),
        v3(0.0, 0.0, 1.0),
        v3(1.0, 1.0, 0.0),
        v3(0.0, 1.0, 1.0),
        v3(1.0, 0.0, 1.0),
        v3(1.0, 1.0, 1.0)
    ];    

    var render_context = text_render_context { };
    render_context.font = font;
    render_context.relative_size = relative_size;
    render_context.foreground_color = regular_font_color;
    render_context.background_color = v3(0.118, 0.118, 0.118);
    gl_state.clear_color = render_context.background_color;
    render_context.background_color_selected = v3(0.118 - 0.05, 0.118 - 0.05, 0.118 - 0.05);
    render_context.alignment = char_alignment::left;
    render_context.quads = &quads;
    render_context.render_width = render_state.render_width;
    render_context.render_height = render_state.render_height;
    
    var temp_memory = &render_state.temp_memory;
    var watermark = start_temp(temp_memory);
    
    
    quads.vertices.data = push(temp_memory, @mm max_chars * 4 * size_of(v3))@v3*;
    quads.vertices.length = max_chars * 4;
    quads.uvs.data = push(temp_memory, @mm max_chars * 4 * size_of(v2))@v2*;
    quads.uvs.length = max_chars* 4;
    quads.colors.data = push(temp_memory, @mm max_chars * 4 * size_of(v4))@v4*;
    quads.colors.length = max_chars * 4;
    quads.background_colors.data = push(temp_memory, @mm max_chars * 4 * size_of(v3))@v3*;
    quads.background_colors.length = max_chars * 4;
    quads.indices.data = push(temp_memory, @mm max_chars * 6 * size_of(i32))@i32*;
    quads.indices.length = max_chars * 6;
    
    var useable_height = render_state.render_height@f32; 
    var line_height = relative_size * font.base_size@f32;
    render_state.visible_line_count = Math::ceil(useable_height / line_height)@i32;
    
    var half_line_height = 0.5 * line_height;
    var start_pos = render_state.text_render_pos;
    
    var p = start_pos;
    p = add(p, render_state.scroll_pos);
    var start_x_text = p.x + 100;
    var start_x_line_numbers = p.x + 50;
    
    var cursor_center = v2z;
    
    var min_safe_y = 0.0;
    var max_safe_y = render_context.render_height@f32 + line_height@f32; 
    
    var total_line_idx = 0;
    for (var chunk_idx = 0; chunk_idx < editor_state.chunks_count; ++chunk_idx) {
        p.x = start_x_line_numbers;
        // p.y -= @f32 first_visible_line_idx * line_height;
        
        render_context.foreground_color = line_font_color;
        render_context.alignment = char_alignment::right;
        
        var current_chunk = editor_state.chunks + chunk_idx;
        var lines = current_chunk.lines;
        var temp_used = start_temp(&temp_memory_arena);
        
        var temp_y = p.y;
        
        
        // render line numbers
        for (var line_idx = 0; line_idx < current_chunk.lines.length; ++line_idx) {
            if (p.y > min_safe_y && p.y < max_safe_y) {
                var line_number = to_str(total_line_idx + line_idx + 1);
                for (var char_idx = line_number.length - 1; char_idx >= 0; --char_idx) {
                    var char = from_ascii(line_number[char_idx]);
                    var char_next = from_ascii(0);
                    if (char_idx < line_number.length - 1) {
                        char_next = from_ascii(line_number[char_idx + 1]);    
                    }
                    add_character(char, char_next, false, &p, &render_context);
                }
            }
            p.y -= line_height;
            p.x = start_x_line_numbers;
        }
        stop_temp(&temp_memory_arena, temp_used);
        render_context.foreground_color = regular_font_color;
        render_context.alignment = char_alignment::left;
        
        p.y = temp_y;
        p.x = start_x_text;
        // render text
        for (var line_idx = 0; line_idx < lines.length; ++line_idx) {
            total_line_idx++;        
            var current_line = lines[line_idx];
            for (var char_idx = 0; char_idx < current_line.length + 1; ++char_idx) {
                var cursor_p = p;
                var should_draw = p.y > min_safe_y && p.y < max_safe_y;
                if (should_draw) {
                    var selected = is_in_selection(editor_state, char_idx, line_idx, chunk_idx);
                    if (char_idx != current_line.length) {
                        var char = *(current_line.chars + char_idx);
                        var char_next = from_ascii(0);
                        if (char_idx < current_line.length - 1) {
                            char_next = *(current_line.chars + (char_idx + 1));    
                        }
                        if (draw_chunk_colors) {
                            render_context.foreground_color = random_colors[chunk_idx % len(random_colors)@i32];    
                        }
                        add_character(char, char_next, selected, &p, &render_context);
                    } else {
                        if (selected && char_idx == 0) {
                            add_character(from_ascii(ord(" ")), from_ascii(0), selected, &p, &render_context);
                        }
                    }
                }
                
                // TODO this should be extracted into a function. We can determine the exact cursor position just using the line height and pseudo rendering the single line the cursor is on (without actually drawing it)
                if (chunk_idx == cursor.pos.z && line_idx == cursor.pos.y && char_idx == cursor.pos.x) {
                    cursor_center.x = cursor_p.x + render_state.scroll_target.x - render_state.scroll_pos.x;
                    
                    cursor_p.x -= 18.0 * relative_size;
                    cursor_p.y += 24.0 * relative_size;
                    
                    cursor_center.y = p.y - half_line_height + render_state.scroll_target.y - render_state.scroll_pos.y;
                    
                    if (cursor.draw_cursor && should_draw) {
                        render_context.relative_size = relative_size * 1.2;
                        add_character(from_ascii(ord("|")), from_ascii(0), false, &cursor_p, &render_context);
                        render_context.relative_size = relative_size;
                    }
                }
            }
            p.y -= line_height;
            p.x = start_x_text;
        }
    }
    
    
    var left_margin:f32 = start_pos.x + 100;
    var cursor_margin = 1.5 * half_line_height;
    if (cursor_center.y - cursor_margin < 0) {
        render_state.scroll_target.y -= (cursor_center.y - cursor_margin);
    }
    if (cursor_center.y + cursor_margin > render_state.render_height@f32) {
        render_state.scroll_target.y += render_state.render_height@f32 - (cursor_center.y + cursor_margin);
    }
    if (cursor_center.x < left_margin) {
        render_state.scroll_target.x -= cursor_center.x - left_margin;
    }
    if (cursor_center.x + cursor_margin > render_state.render_width@f32) {
        render_state.scroll_target.x += render_state.render_width@f32 - (cursor_center.x + cursor_margin);
    }
    
    var t = render_state.delta_time * 25.0;
    render_state.scroll_pos = lerp(render_state.scroll_pos, render_state.scroll_target, t);
    
    
    var current_quad_count = quads.current_quad_count;
    var current_vertex_count = current_quad_count * 4;
    var current_index_count = current_quad_count * 6;
    
    glBindBuffer(GL_ARRAY_BUFFER, font.v_bo);
    glBufferData(GL_ARRAY_BUFFER, @mm current_vertex_count * size_of(v3), quads.vertices.data@ptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * size_of(f32)@\i32, nullptr);
    glEnableVertexAttribArray(0);
    
    glBindBuffer(GL_ARRAY_BUFFER, font.uv_bo);
    glBufferData(GL_ARRAY_BUFFER, @mm current_vertex_count * size_of(v2), quads.uvs.data@ptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 2 * size_of(f32)@\i32, nullptr);
    glEnableVertexAttribArray(1);
    
    glBindBuffer(GL_ARRAY_BUFFER, font.color_bo);
    glBufferData(GL_ARRAY_BUFFER, @mm current_vertex_count * size_of(v4), quads.colors.data@ptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, 4 * size_of(f32)@\i32, nullptr);
    glEnableVertexAttribArray(2);
    
    glBindBuffer(GL_ARRAY_BUFFER, font.background_color_bo);
    glBufferData(GL_ARRAY_BUFFER, @mm current_vertex_count * size_of(v3), quads.background_colors.data@ptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, 3 * size_of(f32)@\i32, nullptr);
    glEnableVertexAttribArray(3);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, font.e_bo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, @mm current_index_count * size_of(i32), quads.indices.data@ptr, GL_DYNAMIC_DRAW);
    
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, font.texture_handle);
    
    glDrawElements(GL_TRIANGLES, current_index_count, GL_UNSIGNED_INT, nullptr);
        
    stop_temp(temp_memory, watermark);
}

