import "../preamble.prag"
import "../vec.prag"
import "../opengl/opengl.prag"
import "../xml.prag"

import "editor_opengl.prag"

let glyph = struct(
    id: i8;
    x_offset: i32;
    y_offset: i32;
    x_advance: i32;
    pos_x: i32;
    pos_y: i32;
    width: i32;
    height: i32;
);


let font = struct (
    texture_handle: i32;
    vbo: i32;
    ebo: i32;
    uvbo: i32;
    
    atlas_width: i32;
    atlas_height: i32;
    base_size: i32;
    line_height: i32;
    
    glyphs: glyph[];
    
    kerning_table: i32[];
);

let set_font_color = fun(foreground_color: v3; background_color: v3) => void {
    glUniform4f(gl_state.foreground_color_uniform_location, foreground_color.x, foreground_color.y, foreground_color.z, 1.0);
    glUniform4f(gl_state.background_color_uniform_location, background_color.x, background_color.y, background_color.z, 1.0);
    gl_state.clear_color = background_color;
}

let load_font = fun() => font {
    var result = font { };
    
    result.texture_handle = load_texture("fonts/atlas.bmp\0", &result.atlas_width, &result.atlas_height);
    glGenBuffers(1, &result.vbo);
    glGenBuffers(1, &result.ebo);
    glGenBuffers(1, &result.uvbo);
    
    let glyph_count = 256;
    
    result.glyphs.data = push(&temp_memory_arena, size_of(glyph) * glyph_count@mm)@glyph*;
    result.glyphs.length = glyph_count;
    
    for (var i = 0; i < glyph_count; ++i) {
        result.glyphs[i] = glyph { };
    }
    var xml = read_xml("fonts/atlas.png.fnt\0");
    var e_font = get_child(&xml, "font");
    assert(e_font@ptr != nullptr);
    from_str(get_attrib_value(get_child(e_font, "info"), "size"), &result.base_size);
    from_str(get_attrib_value(get_child(e_font, "common"), "lineHeight"), &result.base_size);
    
    var e_chars = get_child(e_font, "chars");
    for (var char_idx = 0; char_idx < e_chars.childs.count; char_idx++) {
        var e_char = e_chars.childs.data + char_idx;
        var glyph = glyph { };
        var id_32 = 0;
        from_str(get_attrib_value(e_char, "id"), &id_32);
        assert(id_32 >= 0 && id_32 < glyph_count);
        glyph.id = id_32@i8;
        from_str(get_attrib_value(e_char, "xoffset"), &glyph.x_offset);
        from_str(get_attrib_value(e_char, "yoffset"), &glyph.y_offset);
        from_str(get_attrib_value(e_char, "xadvance"), &glyph.x_advance);
        from_str(get_attrib_value(e_char, "x"), &glyph.pos_x);
        from_str(get_attrib_value(e_char, "y"), &glyph.pos_y);
        from_str(get_attrib_value(e_char, "width"), &glyph.width);
        from_str(get_attrib_value(e_char, "height"), &glyph.height);
        result.glyphs[id_32] = glyph;
    }
    
    var kerning_count: i32;
    from_str(get_attrib_value(get_child(e_font, "kernings"), "count"), &kerning_count);
    if (kerning_count == 0) {
        
        //TODO(pragma): what does this do?
        // var test = AddFontResourceA(cstr("fonts\\TheanoDidot-Regular.ttf\0"));
        var font_handle = CreateFontA(result.base_size, 0, 0, 0,
                                      FW_NORMAL,
                                      0,
                                      0,
                                      0,
                                      DEFAULT_CHARSET,
                                      OUT_DEFAULT_PRECIS,
                                      CLIP_DEFAULT_PRECIS,
                                      ANTIALIASED_QUALITY,
                                      DEFAULT_PITCH|FF_DONTCARE,
                                      cstr("Theano Didot\0"));
        assert(font_handle != Windows::INVALID_HANDLE_VALUE);
        var font_dc = CreateCompatibleDC(GetDC(0));
        SelectObject(font_dc, font_handle);
        var kerning_pair_count = GetKerningPairsA(font_dc, 0, nullptr@KERNINGPAIR*);
        
        var kerning_pairs = @KERNINGPAIR* allocate(size_of(KERNINGPAIR) * kerning_pair_count@mm);
        GetKerningPairsA(font_dc, kerning_pair_count, kerning_pairs);
        
        result.kerning_table.data = @i32* push(&temp_memory_arena, @mm (glyph_count*glyph_count) * size_of(i32));
        result.kerning_table.length = glyph_count*glyph_count;
        memset(result.kerning_table.data@ptr, 0, result.kerning_table.length@mm);
        for (var kerning_pair_idx = 0; kerning_pair_idx < kerning_pair_count; kerning_pair_idx++) {
            var kp = kerning_pairs + kerning_pair_idx;
            var idx = @i32 kp.wSecond * glyph_count + kp.wFirst@i32;
            result.kerning_table[idx] = kp.iKernAmount;
        }
        
        free(kerning_pairs@ptr);
    }
    return result;
}


let map_to_gl = fun(p: v3; width: i32; height: i32) => v3 {
    var result = v3(
        2.0 * (p.x / (width@f32 - 1.0)) - 1.0,
        2.0 * (p.y / (height@f32 - 1.0)) - 1.0,
        p.z
    );
    return result;
}

let get_kerning_pair = fun(font: font*; first: i8; second: i8) => i32 {
    var idx = @i32 second * font.glyphs.length + first@i32;
    return font.kerning_table[idx];
}

let render_text = fun(text: string; font: font*; font_size: f32; start_pos: v2; 
                      client_width: i32; client_height: i32) => void {
    var watermark = temp_memory_arena.used;
    var relative_size = font_size / font.base_size@f32;
    
    var current_quad_count = 0;
    var quads = mesh { }
    ;
    quads.vertices.data = push(&temp_memory_arena, @mm text.length * 4 * size_of(v3))@v3*;
    quads.vertices.length = text.length * 4;
    quads.uvs.data = push(&temp_memory_arena, @mm text.length * 4 * size_of(v2))@v2*;
    quads.uvs.length = text.length * 4;
    quads.indices.data = push(&temp_memory_arena, @mm text.length * 6 * size_of(i32))@i32*;
    quads.indices.length = text.length * 6;
    
    // TODO(pragma): why do i have to zero the triangles
    memset(quads.indices.data@i8*, 0, @mm text.length * 6 * size_of(i32));
    
    // debug_print("render_text", "");
    var p = start_pos;
    for (var char_idx = 0; char_idx < text.length; ++char_idx) {
        var char = text[char_idx];
        var glyph = &font.glyphs[text[char_idx]@i32];
        
        var w = font.atlas_width@f32 - 1.0;
        var h = font.atlas_height@f32 - 1.0;
        var uv0 = v2(glyph.pos_x@f32 / w, 1.0 - glyph.pos_y@f32 / h);
        var uv1 = v2(
            @f32 (glyph.pos_x + glyph.width) / w,
            1.0 - @f32 (glyph.pos_y + glyph.height) / h
        );
        
        
        var p_size = v2(relative_size * glyph.width@f32, relative_size * glyph.height@f32);
        var size = v2(2*p_size.x / (client_width - 1)@f32, 2*p_size.y / (client_height - 1)@f32);
 
        var pos = add(v3(p.x, p.y, 0), v3(relative_size * glyph.x_offset@f32, -relative_size *  glyph.y_offset@f32, 0));
        pos = map_to_gl(v3(pos.x, pos.y, 0), client_width, client_height);
        
        p.x += relative_size * glyph.x_advance@f32;        
        if (char_idx < text.length - 1) {
            var first = text[char_idx];
            var second = text[char_idx + 1];
            var kerning = get_kerning_pair(font, first, second);
            p.x += relative_size * kerning@f32;
        }
        if (char_idx != 0 && char == ord("\n")) {
            p.y -= relative_size * font.base_size@f32;
            p.x = start_pos.x;
        }
        if (char != ord(" ") && char != ord("\n")) {
            current_quad_count = add_quad(&quads, pos, size, uv0, uv1, current_quad_count);    
        }
    }
    
    
    glBindBuffer(GL_ARRAY_BUFFER, font.vbo);
    glBufferData(GL_ARRAY_BUFFER, @mm quads.vertices.length * size_of(v3), quads.vertices.data@ptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * size_of(f32)@\i32, nullptr);
    glEnableVertexAttribArray(0);
    
    glBindBuffer(GL_ARRAY_BUFFER, font.uvbo);
    glBufferData(GL_ARRAY_BUFFER, @mm quads.uvs.length * size_of(v2), quads.uvs.data@ptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 2 * size_of(f32)@\i32, nullptr);
    glEnableVertexAttribArray(1);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, font.ebo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, @mm quads.indices.length * size_of(i32), quads.indices.data@ptr, GL_DYNAMIC_DRAW);
    
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, font.texture_handle);
    
    glDrawElements(GL_TRIANGLES, quads.indices.length, GL_UNSIGNED_INT, nullptr);
        
    
    temp_memory_arena.used = watermark;
}

