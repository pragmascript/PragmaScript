import "../preamble.prag"
import "../vec.prag"
import "../opengl/opengl.prag"
import "../xml.prag"


import "editor.prag"
import "editor_opengl.prag"

let glyph = struct(
    id: i8;
    x_offset: i32;
    y_offset: i32;
    x_advance: i32;
    pos_x: i32;
    pos_y: i32;
    width: i32;
    height: i32;
);


let font = struct (
    texture_handle: i32;
    v_bo: i32;
    e_bo: i32;
    uv_bo: i32;
    color_bo: i32;
    
    atlas_width: i32;
    atlas_height: i32;
    base_size: i32;
    line_height: i32;
    
    glyphs: glyph[];
    
    kerning_table: i32[];
);

let set_font_color = fun(foreground_color: v3; background_color: v3) => void {
    glUniform4f(gl_state.foreground_color_uniform_location, foreground_color.x, foreground_color.y, foreground_color.z, 1.0);
    glUniform4f(gl_state.background_color_uniform_location, background_color.x, background_color.y, background_color.z, 1.0);
    gl_state.clear_color = background_color;
}

let load_font = fun() => font {
    var result = font { };
    
    result.texture_handle = load_texture("fonts/atlas.bmp\0", &result.atlas_width, &result.atlas_height);
    glGenBuffers(1, &result.v_bo);
    glGenBuffers(1, &result.e_bo);
    glGenBuffers(1, &result.uv_bo);
    glGenBuffers(1, &result.color_bo);
    
    let glyph_count = 256;
    
    result.glyphs.data = push(&temp_memory_arena, size_of(glyph) * glyph_count@mm)@glyph*;
    result.glyphs.length = glyph_count;
    
    for (var i = 0; i < glyph_count; ++i) {
        result.glyphs[i] = glyph { };
    }
    var xml = read_xml("fonts/atlas.png.fnt\0");
    var e_font = get_child(&xml, "font");
    assert(e_font@ptr != nullptr);
    from_str(get_attrib_value(get_child(e_font, "info"), "size"), &result.base_size);
    from_str(get_attrib_value(get_child(e_font, "common"), "lineHeight"), &result.base_size);
    
    var e_chars = get_child(e_font, "chars");
    for (var char_idx = 0; char_idx < e_chars.childs.count; char_idx++) {
        var e_char = e_chars.childs.data + char_idx;
        var glyph = glyph { };
        var id_32 = 0;
        from_str(get_attrib_value(e_char, "id"), &id_32);
        assert(id_32 >= 0 && id_32 < glyph_count);
        glyph.id = id_32@i8;
        from_str(get_attrib_value(e_char, "xoffset"), &glyph.x_offset);
        from_str(get_attrib_value(e_char, "yoffset"), &glyph.y_offset);
        from_str(get_attrib_value(e_char, "xadvance"), &glyph.x_advance);
        from_str(get_attrib_value(e_char, "x"), &glyph.pos_x);
        from_str(get_attrib_value(e_char, "y"), &glyph.pos_y);
        from_str(get_attrib_value(e_char, "width"), &glyph.width);
        from_str(get_attrib_value(e_char, "height"), &glyph.height);
        result.glyphs[id_32] = glyph;
    }
    
    var kerning_count: i32;
    from_str(get_attrib_value(get_child(e_font, "kernings"), "count"), &kerning_count);
    if (kerning_count == 0) {
        
        //TODO(pragma): what does this do?
        // var test = AddFontResourceA(cstr("fonts\\TheanoDidot-Regular.ttf\0"));
        var font_handle = CreateFontA(result.base_size, 0, 0, 0,
                                      FW_NORMAL,
                                      0,
                                      0,
                                      0,
                                      DEFAULT_CHARSET,
                                      OUT_DEFAULT_PRECIS,
                                      CLIP_DEFAULT_PRECIS,
                                      ANTIALIASED_QUALITY,
                                      DEFAULT_PITCH|FF_DONTCARE,
                                      cstr("Theano Didot\0"));
        assert(font_handle != Windows::INVALID_HANDLE_VALUE);
        var font_dc = CreateCompatibleDC(GetDC(0));
        SelectObject(font_dc, font_handle);
        var kerning_pair_count = GetKerningPairsA(font_dc, 0, nullptr@KERNINGPAIR*);
        
        var kerning_pairs = @KERNINGPAIR* allocate(size_of(KERNINGPAIR) * kerning_pair_count@mm);
        GetKerningPairsA(font_dc, kerning_pair_count, kerning_pairs);
        
        result.kerning_table.data = @i32* push(&temp_memory_arena, @mm (glyph_count*glyph_count) * size_of(i32));
        result.kerning_table.length = glyph_count*glyph_count;
        memset(result.kerning_table.data@ptr, 0, result.kerning_table.length@mm);
        for (var kerning_pair_idx = 0; kerning_pair_idx < kerning_pair_count; kerning_pair_idx++) {
            var kp = kerning_pairs + kerning_pair_idx;
            var idx = @i32 kp.wSecond * glyph_count + kp.wFirst@i32;
            result.kerning_table[idx] = kp.iKernAmount;
        }
        
        free(kerning_pairs@ptr);
    }
    return result;
}


let map_to_gl = fun(p: v3; width: i32; height: i32) => v3 {
    var result = v3(
        2.0 * (p.x / (width@f32 - 1.0)) - 1.0,
        2.0 * (p.y / (height@f32 - 1.0)) - 1.0,
        p.z
    );
    return result;
}

let get_kerning_pair = fun(font: font*; first: i8; second: i8) => i32 {
    var idx = @i32 second * font.glyphs.length + first@i32;
    return font.kerning_table[idx];
}


let char_alignment = enum( 
    left;
    right;
);

let add_character = fun(char: i8; char_next: i8; font: font*; relative_size: f32;
                        color: v3;
                        alignment: char_alignment;
                        quads: mesh*; p: v2*;
                        client_width: i32; client_height: i32) => void {
    var glyph = &font.glyphs[char@i32];
    var w = font.atlas_width@f32 - 1.0;
    var h = font.atlas_height@f32 - 1.0;
    var uv0 = v2(glyph.pos_x@f32 / w, 1.0 - glyph.pos_y@f32 / h);
    var uv1 = v2(
        @f32 (glyph.pos_x + glyph.width) / w,
        1.0 - @f32 (glyph.pos_y + glyph.height) / h
    );
    var p_size = v2(relative_size * glyph.width@f32, relative_size * glyph.height@f32);
    var size = v2(2*p_size.x / (client_width - 1)@f32, 2*p_size.y / (client_height - 1)@f32);

    var current_p = *p;
    
    var first: i8;
    var second: i8;
    var dir: f32;
    if (alignment == char_alignment::left) {
        first = char;
        second = char_next;
        dir = 1.0;
    }
    elif (alignment == char_alignment::right) {
        first = char_next;
        second = char;
        dir = -1.0;
    }
    p.x += dir * relative_size * glyph.x_advance@f32;
    if (alignment == char_alignment::right) {
        current_p = *p;
    }
    
    var pos = add(v3(current_p.x, current_p.y, 0), v3(relative_size * glyph.x_offset@f32, -relative_size *  glyph.y_offset@f32, 0));
    pos = map_to_gl(v3(pos.x, pos.y, 0), client_width, client_height);
    
    if (char_next != 0) {
        var kerning = get_kerning_pair(font, first, second);
        p.x += dir * relative_size * kerning@f32;
    }        
    if (char != ord(" ") && char != ord("\n")) {
        add_quad(quads, pos, size, uv0, uv1, color);
    }
}

let render_text = fun(editor_state: editor_state*; font: font*; font_size: f32) => void {
    var watermark = start_temp(&temp_memory_arena);
    var cursor = &editor_state.cursor;
    var relative_size = font_size / font.base_size@f32;
    
    var quads = mesh { };
    let max_chars = max_line_length * max_line_count;
    
    let regular_font_color = v3(0.831, 0.831, 0.788);
    let line_font_color = scaled(regular_font_color, 0.3);
    let cursor_font_color = regular_font_color;
    
    quads.vertices.data = push(&temp_memory_arena, @mm max_chars * 4 * size_of(v3))@v3*;
    quads.vertices.length = max_chars * 4;
    quads.uvs.data = push(&temp_memory_arena, @mm max_chars * 4 * size_of(v2))@v2*;
    quads.uvs.length = max_chars* 4;
    quads.colors.data = push(&temp_memory_arena, @mm max_chars * 4 * size_of(v3))@v3*;
    quads.colors.length = max_chars * 4;
    quads.indices.data = push(&temp_memory_arena, @mm max_chars * 6 * size_of(i32))@i32*;
    quads.indices.length = max_chars * 6;
    
    // TODO(pragma): why do i have to zero the triangle indices??
    memset(quads.indices.data@i8*, 0, @mm quads.indices.length * size_of(i32));
    
    var lines = editor_state.lines;

    var start_pos = editor_state.text_render_pos;
    var p = start_pos;
    var line_number_delta_x = 50 + start_pos.x;
    p.x = line_number_delta_x;
    var temp_used = start_temp(&temp_memory_arena);
    // render line numbers
    for (var line_idx = 0; line_idx < lines.length; ++line_idx) {
        var line_number = to_str(line_idx + 1);
        for (var char_idx = line_number.length - 1; char_idx >= 0; --char_idx) {
            var char = line_number[char_idx];
            var char_next: i8 = 0;
            if (char_idx < line_number.length - 1) {
                char_next = line_number[char_idx + 1];    
            }
            add_character(char, char_next, font, relative_size, line_font_color, char_alignment::right, &quads, &p, editor_state.render_width, editor_state.render_height);
        }
        p.y -= relative_size * font.base_size@f32;
        p.x = line_number_delta_x;
    }
    stop_temp(&temp_memory_arena, temp_used);
    
    p = start_pos;
    p.x += 100;
    var start_x = start_pos.x + 100;
    
    // render text
    for (var line_idx = 0; line_idx < lines.length; ++line_idx) {
        var current_line = lines[line_idx];
        for (var char_idx = 0; char_idx < current_line.length + 1; ++char_idx) {
            var cursor_p = p;
            if (char_idx != current_line.length) {
                var char = current_line[char_idx];
                var char_next: i8 = 0;
                if (char_idx < current_line.length - 1) {
                    char_next = current_line[char_idx + 1];    
                }
                add_character(char, char_next, font, relative_size, regular_font_color, char_alignment::left, &quads, &p, editor_state.render_width, editor_state.render_height);
            }
            if (cursor.draw_cursor && line_idx == cursor.line_pos && char_idx == cursor.char_pos) {
                cursor_p.x -= 18.0 * relative_size;
                cursor_p.y += 24.0 * relative_size;
                add_character(ord("|"), 0, font, relative_size*1.2, cursor_font_color, char_alignment::left, &quads, &cursor_p, editor_state.render_width, editor_state.render_height);
            }
        }
        p.y -= relative_size * font.base_size@f32;
        p.x = start_x;
    }
    
    glBindBuffer(GL_ARRAY_BUFFER, font.v_bo);
    glBufferData(GL_ARRAY_BUFFER, @mm quads.vertices.length * size_of(v3), quads.vertices.data@ptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * size_of(f32)@\i32, nullptr);
    glEnableVertexAttribArray(0);
    
    glBindBuffer(GL_ARRAY_BUFFER, font.uv_bo);
    glBufferData(GL_ARRAY_BUFFER, @mm quads.uvs.length * size_of(v2), quads.uvs.data@ptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 2 * size_of(f32)@\i32, nullptr);
    glEnableVertexAttribArray(1);
    
    glBindBuffer(GL_ARRAY_BUFFER, font.color_bo);
    glBufferData(GL_ARRAY_BUFFER, @mm quads.colors.length * size_of(v3), quads.colors.data@ptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 3 * size_of(f32)@\i32, nullptr);
    glEnableVertexAttribArray(2);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, font.e_bo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, @mm quads.indices.length * size_of(i32), quads.indices.data@ptr, GL_DYNAMIC_DRAW);
    
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, font.texture_handle);
    
    glDrawElements(GL_TRIANGLES, quads.indices.length, GL_UNSIGNED_INT, nullptr);
        
    stop_temp(&temp_memory_arena, watermark);
}

