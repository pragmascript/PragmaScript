import "../preamble.prag"
import "../windows.prag"
import "../math.prag"
import "../memory.prag"
import "../vec.prag"


import "editor_opengl.prag"


with Windows;

// https://hero.handmade.network/forums/code-discussion/t/129-howto_-_building_without_import_libraries

let window_state = struct 
(
    handle: mm;
    dc: mm;
    client_width: i32;
    client_height: i32;
    wants_to_quit: bool;
);
var window: window_state;
let process_pending_messages = fun() => void {
    var msg: MSG;
    while (PeekMessageA(&msg, null, 0, 0, PM_REMOVE|PM_NOYIELD) != 0) {
        var message = msg.message;
        if (message == WM_QUIT) {
            window.wants_to_quit = true;
        } 
        elif (message == WM_SYSKEYDOWN
            || message == WM_SYSKEYUP
            || message == WM_KEYDOWN
            || message == WM_KEYUP) {

            var w_param = @i32 (msg.wParam >> 32@mm);
            var l_param = @i32 (msg.lParam >> 32@mm);
            var vk_code = w_param;

            var was_down = (l_param & (1 << 30)) != 0;
            var is_down = (l_param & (1 << 31)) == 0;
            var key_up = was_down && !is_down;
            var key_down = !was_down && is_down; 
            
            // https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-keydown
            // TODO(pragma): handl repeat keys!
            
            if (key_down) {
                handle_editor_key_down(vk_code);
            }
            if (key_up) {
                handle_editor_key_up(vk_code);
            }

            if(vk_code == VK_ESCAPE) {
                window.wants_to_quit = true;
            }
        } else {
            TranslateMessage(&msg);
            DispatchMessageA(&msg);
        }
    }
}

let PROCESS_SYSTEM_DPI_AWARE = 1;
let SetProcessDpiAwareness = extern fun(
    value: i32;
) => i32;

let main_window_callback = fun
(
    window_handle: mm;
    message: i32;
    w_param: mm;
    l_param: mm;
) => mm {
    var result = null;
    if (message == WM_SIZE || message == WM_SIZING) {
    }
    elif (message == WM_CLOSE) {
        window.wants_to_quit = true;
    }
    elif (message == WM_DESTROY) {
        window.wants_to_quit = true;
    }
    elif (message == WM_PAINT) {
        var paint: PAINTSTRUCT;
        var context = BeginPaint(window_handle, &paint);
        // blit_to_screen(window.dc, &window.backbuffer);
        EndPaint(window_handle, &paint);
    } 
    else {
        result = DefWindowProcA(window_handle, message, w_param, l_param);
    }
    return result;
}

let cursor = struct(
    line_pos: i32;
    char_pos: i32;
    target_char_pos: i32;
    draw_cursor: bool;
    cursor_last_blink_time: f32;
);

let editor_state = struct(
    lines: string[];
    
    keyboard_state: i8*;
    shift_pressed: bool;
    
    cursor: cursor;
    
    time: f32;
);


let max_line_length = 1024;
let max_line_count = 32;

let create_editor_state = fun() => editor_state  {
    var result = editor_state { };
    result.cursor.line_pos = 0;
    result.cursor.char_pos = 0;
    result.lines.data = allocate(size_of(string) * max_line_count@mm)@string*;
    result.lines.length = max_line_count;
    result.keyboard_state = allocate(256);

    var line_size = size_of(i8) * max_line_length@mm;    
    var text_block_size = line_size * max_line_count@mm;
    var text_block_ptr = allocate(text_block_size);
    
    for (var line_idx = 0; line_idx < max_line_count; ++line_idx) {
        result.lines[line_idx].length = 0;
        result.lines[line_idx].data = text_block_ptr;
        text_block_ptr += line_size;
    }
    return result;
}
var editor_state: editor_state;

// let printable = fun (vk_code: i32) => bool {
//     if (vk_code >= ord("A")@i32 && vk_code <= ord("Z")@i32) {
//         return true;
//     }
//     elif (vk_code >= ord("0")@i32 && vk_code <= ord("9")@i32) {
//         return true;
//     }
//     elif (vk_code == VK_SPACE) {
//         return true;
//     }
//     return false;
// }

let printable = fun(char: i8) => bool {
    return char >= 32 & char <= 126;
}

let to_upper = fun(char: i8) => i8 {
    var result = char;
    if (char >= ord("a") && char <= ord("z")) {
        result += ord("A") - ord("a");
    }
    return result;
}

let to_lower = fun(char: i8) => i8 {
    var result = char;
    if (char >= ord("A") && char <= ord("Z")) {
        result -= ord("A") - ord("a");
    }
    return result;
}

let reset_cursor_blink = fun() => void {
    editor_state.cursor.draw_cursor = true;
    editor_state.cursor.cursor_last_blink_time = editor_state.time;
}

let handle_editor_key_down = fun(vk_code: i32) => void {
    var cursor = &editor_state.cursor;
    var lines = editor_state.lines;
    
    // TODO(pragma): this is really ugly. there needs to be a better way to do this.
    var current_line = lines[cursor.line_pos];
    var current_line_ptr = &lines[cursor.line_pos];
    
    var char_word: i16 = 0;
    GetKeyboardState(editor_state.keyboard_state);
    ToAscii(vk_code, vk_code, editor_state.keyboard_state, &char_word, 0);
    assert(char_word >= 0 && char_word < 256);
    var char: i8 = char_word@i8;
    
    var should_reset_blink = false;
    
    if (printable(char@i8)) {
        current_line[current_line_ptr.length++] = char@i8;
        cursor.char_pos++;
        should_reset_blink = true;
    }
    elif (vk_code == VK_BACK) {
        if (current_line.length > 0) {
            current_line[current_line_ptr.length--] = 0;
            cursor.char_pos--;
            should_reset_blink = true;
        } else {
            if (cursor.line_pos > 0) {
                cursor.line_pos--;
                current_line = lines[cursor.line_pos];
                current_line_ptr = &lines[cursor.line_pos];
                cursor.char_pos = current_line.length;
                
                // TODO(pragma): this should not be done line by line: this is just one big memcpy.
                for (var line_idx = cursor.line_pos; line_idx < max_line_count - 1; ++line_idx) {
                    var src_line = lines[line_idx + 1];
                    var dest_line = lines[line_idx];
                    memcpy(dest_line.data, src_line.data, src_line.length@mm);
                }
            }
        }
    }
    elif (vk_code == VK_RETURN) {
        cursor.line_pos++;
        cursor.char_pos = 0;
        should_reset_blink = true;
    }
    elif (vk_code == VK_SHIFT) {
        editor_state.shift_pressed = true;
    }
    elif (vk_code == VK_LEFT) {
        if (cursor.char_pos > 0) {
            cursor.char_pos--;
            should_reset_blink = true;
        } else {
            if (cursor.line_pos > 0) {
               cursor.line_pos--;    
               should_reset_blink = true;
               cursor.char_pos = lines[cursor.line_pos].length;
            }
        }
    }
    elif (vk_code == VK_RIGHT) {
        if (cursor.char_pos < current_line.length) {
            cursor.char_pos++;
            should_reset_blink = true;
        } else {
            if (cursor.line_pos < max_line_count - 1) {
                cursor.line_pos++;
                should_reset_blink = true;    
            }
        }
    }
    elif (vk_code == VK_UP) {
        if (cursor.line_pos > 0) {
            cursor.line_pos--;
        }
    }
    elif (vk_code == VK_DOWN) {
        if (cursor.line_pos < max_line_count - 1) {
            cursor.line_pos++;
        }
    }
    cursor.line_pos = Math::clamp(cursor.line_pos, 0, max_line_count - 1);
    
    if (should_reset_blink) {
        reset_cursor_blink();
    }
    
    // debug_print("key_down", vk_code);
    // debug_print("new_text", current_line);
    // debug_print("new_text.length", current_line_ptr.length);
}

let handle_editor_key_up = fun(vk_code: i32) => void {
    // debug_print("key_up", vk_code);
    if (vk_code == VK_SHIFT) {
        editor_state.shift_pressed = false;
    }
}


[
	"compile.output": "edit.exe",
	"compile.entry" : "true",
 	"compile.opt"   : "0",
    "compile.debuginfo": "true",
    "compile.ll"    : "false",
    "compile.asm"   : "false",
    "compile.cpu"   : "native", // "sandybridge",
 	"compile.run"   : "true",
 	"compile.libs"  : "kernel32.lib, user32.lib, gdi32.lib, shcore.lib, libopenlibm.a, opengl32.lib",
	"compile.path"  : "C:\Program Files (x86)\Windows Kits\10\Lib\10.0.14393.0\um\x64, lib"
]
let main = fun() => void {
    QueryPerformanceFrequency(&perf_count_freq);

    SetProcessDpiAwareness(PROCESS_SYSTEM_DPI_AWARE);

    var t0 = get_perf_counter();
    
    let buffer_width  = 1920;
    let buffer_height = 1080;
    

    var client_rect = RECT { 0, 0, buffer_width, buffer_height };
    AdjustWindowRectEx(&client_rect, dw_style, 0, dw_ex_style);

    var window_width = client_rect.right - client_rect.left;
    assert(window_width > 0);
    var window_height = client_rect.bottom - client_rect.top;
    assert(window_height > 0);
    window.client_width = buffer_width;
    window.client_height = buffer_height;
    
    var class_name  = cstr("editor_window_class\0");
    var window_name = cstr("editor test\0");
    var module_handle = GetModuleHandleA(null);
    var window_class = WNDCLASSEX {};
    window_class.cbSize = size_of(WNDCLASSEX)@i32;
    window_class.style = CS_HREDRAW|CS_VREDRAW;
    window_class.lpfnWndProc = @ptr main_window_callback;
    window_class.hInstance = module_handle;
    window_class.lpszClassName = class_name;
    window_class.hCursor = LoadCursorA(null, IDC_ARROW);
    RegisterClassExA(&window_class);
    
    let dw_style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_VISIBLE;
    let dw_ex_style = 0 & WS_EX_TOPMOST;
 
    window.handle = CreateWindowExA(
        dw_ex_style,
        class_name,
        window_name,
        dw_style,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        window_width,
        window_height,
        null,
        null,
        module_handle,
        null
    );
    window.dc = GetDC(window.handle);
    
    var gl_t0 = get_perf_counter();
    init_opengl(window.dc);
    init_gl_resources();
    var gl_t1 = get_perf_counter();

    // debug_print_f64("init opengl time: ", get_seconds_elapsed(gl_t0, gl_t1));
    var frames = 0;
    
    editor_state = create_editor_state();

    var start_time = get_perf_counter();
    while (!window.wants_to_quit) {
        process_pending_messages();
        var t0 = get_perf_counter();
        var time = get_seconds_elapsed(start_time, t0);
        editor_state.time = time@f32;
        render_opengl(window.client_width, window.client_height, &editor_state, window.dc);
        var t1 = get_perf_counter();
        frames++;
        if (frames == 600) {
            // debug_print("ms elapsed: ", get_seconds_elapsed(t0, t1) * 1000.0);
            frames = 0;
        }
    }
    ExitProcess(0);
}
