import "../preamble.prag"
import "../windows.prag"
import "../math.prag"
import "../memory.prag"
import "../vec.prag"

import "editor_opengl.prag"

with Windows;

// https://hero.handmade.network/forums/code-discussion/t/129-howto_-_building_without_import_libraries


let max_line_length = 1024;
let max_line_count = 64;
let key_repeat_delay = 0.5;
let key_repeat_interval = 0.020;


let window_state = struct 
(
    handle: mm;
    dc: mm;
    client_width: i32;
    client_height: i32;
    wants_to_quit: bool;
);
var window: window_state;
let process_pending_messages = fun() => void {
    var msg: MSG;
    while (PeekMessageA(&msg, null, 0, 0, PM_REMOVE|PM_NOYIELD) != 0) {
        var message = msg.message;
        if (message == WM_QUIT) {
            window.wants_to_quit = true;
        } 
        elif (message == WM_SYSKEYDOWN
            || message == WM_SYSKEYUP
            || message == WM_KEYDOWN
            || message == WM_KEYUP) {

            // TODO(pragma): read this https://blog.molecular-matters.com/2011/09/05/properly-handling-keyboard-input/

            var w_param = @i32 (msg.wParam >> 32@mm);
            var l_param = @i32 (msg.lParam >> 32@mm);
            var vk_code = w_param;

            var was_down = (l_param & (1 << 30)) != 0;
            var is_down = (l_param & (1 << 31)) == 0;
            var key_up = was_down && !is_down;
            var key_down = !was_down && is_down; 
            
            // debug_print("w_param", w_param);
            // debug_print("l_param", l_param);
            
            if (key_down) {
                handle_editor_key_down(vk_code);
                editor_state.key_down_state[vk_code].last_key_down_time = editor_state.render_state.time;
            }
            if (key_up) {
                handle_editor_key_up(vk_code);
            }
            if (is_down) {
                var time = editor_state.render_state.time;
                var key_down_state = &editor_state.key_down_state[vk_code];
                if (time - key_down_state.last_key_down_time > key_repeat_delay) {
                    if (time - key_down_state.last_last_key_repeat_time > key_repeat_interval) {
                        key_down_state.last_last_key_repeat_time = time;
                        handle_editor_key_down(vk_code);
                    }
                }
            }
            if(vk_code == VK_ESCAPE) {
                window.wants_to_quit = true;
            }
        } else {
            TranslateMessage(&msg);
            DispatchMessageA(&msg);
        }
    }
}

let PROCESS_SYSTEM_DPI_AWARE = 1;
let SetProcessDpiAwareness = extern fun(
    value: i32;
) => i32;
let SetProcessDPIAware = extern fun(
) => i32;

let main_window_callback = fun
(
    window_handle: mm;
    message: i32;
    w_param: mm;
    l_param: mm;
) => mm {
    var result = null;
    if (message == WM_SIZE || message == WM_SIZING) {
    }
    elif (message == WM_CLOSE) {
        window.wants_to_quit = true;
    }
    elif (message == WM_DESTROY) {
        window.wants_to_quit = true;
    }
    elif (message == WM_PAINT) {
        var paint: PAINTSTRUCT;
        var context = BeginPaint(window_handle, &paint);
        // blit_to_screen(window.dc, &window.backbuffer);
        EndPaint(window_handle, &paint);
    } 
    else {
        result = DefWindowProcA(window_handle, message, w_param, l_param);
    }
    return result;
}

let cursor = struct(
    pos: v2i;
    last_valid_char_pos: i32;
    target_char_pos: i32;
    
    draw_cursor: bool;
    cursor_last_blink_time: f32;
    
    selection_active: bool;
    selection_start: v2i;
    
    clipboard: string;
);

let key_down_state = struct(
    last_key_down_time: f32;
    last_last_key_repeat_time: f32;
);

let render_state = struct(
    render_width: i32;
    render_height: i32;
    time: f32;        
    delta_time: f32;
    text_render_pos: v2;
    scroll_pos: v2;
    scroll_target: v2;
    font_size: f32;
    target_font_size: f32;
    visible_line_count: i32;
);

let editor_state = struct(
    lines: string[];
    keyboard_state: i8*;
    shift_pressed: bool;
    control_pressed: bool;
    cursor: cursor;
    key_down_state: key_down_state[];
    render_state: render_state;
);

let create_editor_state = fun() => editor_state  {
    var result = editor_state { };
    result.cursor.pos = v2iz;
    result.cursor.last_valid_char_pos = 0;
    result.lines.data = allocate(size_of(string) * max_line_count@mm)@string*;
    result.lines.length = 1;
    result.keyboard_state = allocate(256);

    var line_size = size_of(i8) * max_line_length@mm;    
    var text_block_size = line_size * max_line_count@mm;
    var text_block_ptr = allocate(text_block_size);
    
    for (var line_idx = 0; line_idx < max_line_count; ++line_idx) {
        result.lines[line_idx].length = 0;
        result.lines[line_idx].data = text_block_ptr;
        text_block_ptr += line_size;
    }
    
    result.key_down_state.data = @key_down_state* allocate(256 * size_of(key_down_state));
    result.key_down_state.length = 256;
    
    result.render_state.font_size = 74;
    result.render_state.target_font_size = 74;
    
    
    return result;
}
var editor_state: editor_state;

let is_printable = fun(char: i8) => bool {
    return char >= 32 & char <= 126;
}

let reset_cursor_blink = fun() => void {
    editor_state.cursor.draw_cursor = true;
    editor_state.cursor.cursor_last_blink_time = editor_state.render_state.time;
}

let get_ordered_selection_bounds = fun(editor_state: editor_state*; first: v2i*; last: v2i*) => void {
    *first = editor_state.cursor.selection_start;
    *last = editor_state.cursor.pos;
    if (first.y > last.y) {
        var temp = *first;
        *first = *last;
        *last = temp;
    }
    if (first.y == last.y && first.x > last.x) {
        var temp = *first;
        *first = *last;
        *last = temp;
    }
}

let is_in_selection = fun(editor_state: editor_state*; char_idx: i32; line_idx: i32) => bool {
    if (!editor_state.cursor.selection_active) {
        return false;
    }
    var first: v2i;
    var last: v2i;
    get_ordered_selection_bounds(editor_state, &first, &last);
    if (line_idx < first.y || line_idx > last.y) {
        return false;
    }
    var result = true;
    if (line_idx == first.y) {
        if (char_idx < first.x) {
            result = false;
        }
    }
    if (line_idx == last.y) {
        if (char_idx >= last.x) {
            result = false;
        }
    }
    return result;
}

let delete_selection = fun(editor_state: editor_state*) => void {
    var cursor = &editor_state.cursor;
    assert(cursor.selection_active);
    
    var first: v2i;
    var last: v2i;
    get_ordered_selection_bounds(editor_state, &first, &last);
    
    delete_bounds(editor_state, first, last);
    
    cursor.pos = first;
    editor_state.cursor.selection_active = false;
}

let delete_bounds = fun(editor_state: editor_state*; first: v2i; last: v2i) => void {
    var dest_line = editor_state.lines[first.y];
    var src_line = editor_state.lines[last.y];
    
    var dest_idx = first.x;
    for (var src_idx = last.x; src_idx < src_line.length; ++src_idx) {
        dest_line[dest_idx++] = src_line[src_idx];
    }
    
    if (first.y == last.y) {
        editor_state.lines[first.y].length -= last.x - first.x;
    } else {
        editor_state.lines[first.y].length -= (dest_line.length - 1) - first.x;
        editor_state.lines[first.y].length += (src_line.length - 1) - last.x;
        assert(editor_state.lines[first.y].length >= 0);
    }
    var dest_line_idx = first.y + 1;
    var copy_count = 0;
    for (var src_line_idx = last.y + 1; src_line_idx < editor_state.lines.length; ++src_line_idx) {
        var src_line = &editor_state.lines[src_line_idx];
        assert(dest_line_idx < editor_state.lines.length);
        var dest_line = &editor_state.lines[dest_line_idx];
        memcpy(dest_line.data, src_line.data, src_line.length@mm);
        dest_line.length = src_line.length;
        dest_line_idx++;
    }
    editor_state.lines.length -= last.y - first.y;
    assert(editor_state.lines.length > 0);
}

let delete_line = fun(editor_state: editor_state*; target_line_idx: i32) => void {
    for (var line_idx = target_line_idx; line_idx < editor_state.lines.length - 1; ++line_idx) {
        var dest_line = editor_state.lines[line_idx];
        var src_line = editor_state.lines[line_idx + 1];
        memcpy(dest_line.data, src_line.data, src_line.length@mm);
        editor_state.lines[line_idx].length = src_line.length;
    }
    editor_state.lines[editor_state.lines.length - 1].length = 0;
    if (editor_state.lines.length > 1) {
        editor_state.lines.length--;    
    }
}

// TODO(pragma): implement this like delete_selection()
let paste_clipboard = fun(editor_state: editor_state*) => void {
    var watermark = start_temp(&temp_memory_arena);
    
    var cursor = &editor_state.cursor;
    
    /// var clipboard = cursor.clipboard;
    assert(Windows::OpenClipboard(window.handle) != 0);
    
    var global_memory_handle = Windows::GetClipboardData(Windows::CF_TEXT);
    if (global_memory_handle != 0)
    {
        var global_memory_ptr = Windows::GlobalLock(global_memory_handle);
        assert(global_memory_ptr != nullptr);
        var char_count = strlen(global_memory_ptr);
        var clipboard = make_string(char_count@i32);
        memcpy(clipboard.data, global_memory_ptr, clipboard.length@mm);
        Windows::GlobalUnlock(global_memory_handle);
        
        var lines = editor_state.lines;
        var current_line = lines[cursor.pos.y];
        var current_line_ptr = &lines[cursor.pos.y];
        for (var idx = 0; idx < clipboard.length; ++idx) {
            var char = clipboard[idx];
            if (char == 13) {
                continue;
            }
            if (char != ord("\n")) {
                add_char_to_line(current_line_ptr, cursor, char);
                cursor.last_valid_char_pos = cursor.pos.x;
            } else {
                handle_editor_key_down(VK_RETURN);
                current_line = lines[cursor.pos.y];
                current_line_ptr = &lines[cursor.pos.y];
            }
        }
    }
    Windows::CloseClipboard();
    stop_temp(&temp_memory_arena, watermark);
}

let add_char_to_line = fun(line_ptr: string*; cursor: cursor*; char: i8) => void {
    if (line_ptr.length + 1 < max_line_length) {
        for (var char_idx = line_ptr.length - 1; char_idx >= cursor.pos.x; --char_idx) {
            *(line_ptr.data + (char_idx + 1)) = *(line_ptr.data + char_idx);
        }
        line_ptr.length++;
        *(line_ptr.data + cursor.pos.x++) = char;
    }
}

let copy_to_clipboard = fun(editor_state: editor_state*) => void {
    var cursor = &editor_state.cursor;
    if (cursor.clipboard.data != nullptr) {
        free(cursor.clipboard.data);
    }
    var watermark = start_temp(&temp_memory_arena);
    
    var first: v2i;
    var last: v2i;
    get_ordered_selection_bounds(editor_state, &first, &last);
    
    var char_ptr: i8* = nullptr;
    var char_count = 0;

    for (var y = first.y; y <= last.y; ++y) {
        var current_line = editor_state.lines[y];
        var first_x = 0;
        var last_x = current_line.length;
        if (y == first.y) {
            first_x = first.x;
        }
        if (y == last.y) {
            last_x = last.x;
        }
        for (var x = first_x; x < last_x; ++x) {
            char_ptr = push(&temp_memory_arena, 1);
            *char_ptr = current_line[x];
            char_count++;
        }
        if (y != last.y) {
            char_ptr = push(&temp_memory_arena, 1);
            *char_ptr = ord("\n");
            char_count++;
        }
    }
    
    if (char_count > 0) {
        cursor.clipboard.data = allocate(char_count@mm + 1);
        cursor.clipboard.length = char_count;
        var dest = cursor.clipboard.data;
        var src = char_ptr - (char_count - 1);
        memcpy(dest, src, char_count@mm);
        
        // null terminate for windows clipboard handling
        cursor.clipboard[cursor.clipboard.length] = 0;
    } else {
        return;
    }
    assert(Windows::OpenClipboard(window.handle) != 0);
    assert(Windows::EmptyClipboard() != 0);
    
    var global_mem_handle = Windows::GlobalAlloc(Windows::GMEM_MOVEABLE, (char_count + 1)@mm);
    assert(global_mem_handle != 0);    
    
    var global_mem_ptr = Windows::GlobalLock(global_mem_handle);
    assert(global_mem_ptr != nullptr);
    memcpy(global_mem_ptr, cursor.clipboard.data, (char_count + 1)@mm);
    Windows::GlobalUnlock(global_mem_handle);
    assert(Windows::SetClipboardData(Windows::CF_TEXT, global_mem_handle) != 0);
    
    // var clipboard_ptr = Windows::GlobalLock(clipboard_handle);
    // assert(clipboard_ptr != nullptr);
    // Windows::GlobalUnlock(clipboard_handle);
    
    assert(Windows::CloseClipboard() != 0);
    
    stop_temp(&temp_memory_arena, watermark);
}

    


let next_word = fun(editor_state: editor_state*) => void { 
    var line = editor_state.lines[editor_state.cursor.pos.y];
    var cursor = &editor_state.cursor;
    
    if (cursor.pos.x >= line.length) {
        return;
    }
    
    for (var char = line[cursor.pos.x]; cursor.pos.x < line.length && is_whitespace(char); cursor.pos.x++) { 
        char = line[cursor.pos.x];
    }
    cursor.pos.x++;
    
    for (var char = line[cursor.pos.x]; cursor.pos.x < line.length; cursor.pos.x++) {
        char = line[cursor.pos.x];
        if (!is_identifier_char(char)) {
            break;
        }
    }
}

let prev_word = fun(editor_state: editor_state*) => void { 
    var line = editor_state.lines[editor_state.cursor.pos.y];
    var cursor = &editor_state.cursor;
    if (cursor.pos.x == 0) {
        return;
    }
    cursor.pos.x--;
    for (var char = line[cursor.pos.x]; cursor.pos.x > 0 && is_whitespace(char); cursor.pos.x--) { 
        char = line[cursor.pos.x];
    }
    if (is_identifier_char(line[cursor.pos.x])) {
        for (var char = line[cursor.pos.x]; cursor.pos.x > 0; cursor.pos.x--) {
            char = line[cursor.pos.x];
            if (!is_identifier_char(char)) {
                cursor.pos.x++;
                break;
            }
        }
    }
}

let handle_editor_key_down = fun(vk_code: i32) => void {
    var cursor = &editor_state.cursor;
    var old_cursor_pos = cursor.pos;
    var lines = editor_state.lines;
    var lines_ptr = &editor_state.lines;
    
    // TODO(pragma): this is really ugly. there needs to be a better way to do this.
    var current_line = lines[cursor.pos.y];
    var current_line_ptr = &lines[cursor.pos.y];
    
    assert(current_line.length >= 0 && current_line.length < max_line_length);
    assert(cursor.pos.x <= current_line.length);
    assert(cursor.pos.y < lines.length);
    assert(lines.length <= max_line_count);
    assert(lines.length > 0);
    
    var char_word: i16 = 0;
    GetKeyboardState(editor_state.keyboard_state);
    ToAscii(vk_code, vk_code, editor_state.keyboard_state, &char_word, 0);
    // assert(char_word >= 0 && char_word < 256);
    char_word = 0xFF & char_word;
    
    var char: i8 = char_word@i8;
    var should_clear_selection = true;
    var should_reset_blink = false;
    if (is_printable(char@i8)) {
        if (editor_state.cursor.selection_active) {
            delete_selection(&editor_state);
            current_line = lines[cursor.pos.y];
            current_line_ptr = &lines[cursor.pos.y];
        }
        should_reset_blink = true;
        add_char_to_line(current_line_ptr, cursor, char);
        cursor.last_valid_char_pos = cursor.pos.x;
    }
    elif (vk_code == VK_BACK) {
        should_reset_blink= true;
        if (cursor.selection_active) {
            delete_selection(&editor_state);
            cursor.last_valid_char_pos = cursor.pos.x;
        } else {
            if (cursor.pos.x > 0) {
                current_line_ptr.length--;
                for (var char_idx = cursor.pos.x - 1; char_idx < current_line.length - 1; ++char_idx) {
                    current_line[char_idx] = current_line[char_idx + 1];
                }
                current_line[current_line_ptr.length] = 0;
                cursor.pos.x--;
            } else {
                if (cursor.pos.y > 0) {
                    var dest_line = lines[cursor.pos.y - 1];
                    cursor.pos.x = dest_line.length;
                    var src_line = lines[cursor.pos.y];
                    for (var char_idx = 0; char_idx < src_line.length; ++char_idx) {
                        dest_line[dest_line.length + char_idx] = src_line[char_idx];
                        src_line[char_idx] = 0;
                    }
                    lines[cursor.pos.y - 1].length += src_line.length;
                    lines[cursor.pos.y].length = 0;
                    assert(lines[cursor.pos.y - 1].length < max_line_length);

                    for (var line_idx = cursor.pos.y; line_idx < lines.length; ++line_idx) {
                        var src_line = lines[line_idx + 1];
                        var dest_line = lines[line_idx];
                        memcpy(dest_line.data, src_line.data, src_line.length@mm);
                        lines[line_idx].length = src_line.length;
                    }
                    lines[lines.length - 1].length = 0;
                    lines_ptr.length--;
                    cursor.pos.y--;
                }
            }
            cursor.last_valid_char_pos = cursor.pos.x;
        }
    }
    elif (vk_code == VK_DELETE) {
        should_reset_blink = true;
        if (cursor.selection_active) {
            delete_selection(&editor_state);
            cursor.last_valid_char_pos = cursor.pos.x;
        } else {
            if (cursor.pos.x < current_line.length) {
                for (var char_idx = cursor.pos.x; char_idx < current_line.length; ++char_idx) {
                    if (char_idx == current_line.length - 1) {
                        current_line[char_idx] = 0;
                    } else {
                        current_line[char_idx] = current_line[char_idx + 1];
                    }
                }
                current_line_ptr.length--;
            } else {
                if (cursor.pos.y < lines.length - 1) {
                    var next_line = lines[cursor.pos.y + 1];
                    for (var char_idx = 0; char_idx < next_line.length; ++char_idx) {
                        current_line[cursor.pos.x + char_idx] = next_line[char_idx];
                    }
                    current_line_ptr.length += next_line.length;
                    for (var line_idx = cursor.pos.y + 1; line_idx < max_line_count; ++line_idx) {
                        var src_line = lines[line_idx + 1];
                        var dest_line = lines[line_idx];
                        memcpy(dest_line.data, src_line.data, src_line.length@mm);
                        lines[line_idx].length = src_line.length;
                    }
                    assert(lines_ptr.length > 0);
                    lines_ptr.length--;
                }
            }
        }
    }
    elif (vk_code == VK_RETURN) {
        if (cursor.selection_active) {
            delete_selection(&editor_state);
            current_line = lines[cursor.pos.y];
            current_line_ptr = &lines[cursor.pos.y];
        }
        if (lines.length < max_line_count) {
            should_reset_blink = true;
            for (var line_idx = max_line_count - 2; line_idx > cursor.pos.y; --line_idx) {
                var src_line = lines[line_idx];
                var dest_line = lines[line_idx + 1];
                memcpy(dest_line.data, src_line.data, src_line.length@mm);
                lines[line_idx + 1].length = src_line.length;
            }
            cursor.pos.y++;
            lines_ptr.length++;
            
            var new_line = lines[cursor.pos.y];
            memset(new_line.data, 0, max_line_length@mm);
            var temp_pos = 0;
            for (var char_idx = cursor.pos.x; char_idx < current_line.length; ++char_idx) {
                new_line[temp_pos++] = current_line[char_idx];
                current_line[char_idx] = 0;
            }
            current_line_ptr.length = cursor.pos.x;
            lines[cursor.pos.y].length = temp_pos;
            
            cursor.pos.x = 0;
            cursor.last_valid_char_pos = cursor.pos.x;    
        }
    }
    elif (vk_code == VK_SHIFT) {
        editor_state.shift_pressed = true;
        should_clear_selection = false;
    }
    elif (vk_code == VK_CONTROL) {
        editor_state.control_pressed = true;
        should_clear_selection = false;
    }
    elif (vk_code == VK_LEFT) {
        should_reset_blink = true;
        if (cursor.pos.x > 0) {
            if (editor_state.control_pressed) {
                prev_word(&editor_state);
            } else {
                cursor.pos.x--;    
            }
        } else {
            if (cursor.pos.y > 0) {
            cursor.pos.y--;    
            cursor.pos.x = lines[cursor.pos.y].length;
            }
        }
        cursor.last_valid_char_pos = cursor.pos.x;
    }
    elif (vk_code == VK_RIGHT) {
        should_reset_blink = true;
        if (cursor.pos.x < current_line.length) {
            if (editor_state.control_pressed) {
                next_word(&editor_state);
            } else {
                cursor.pos.x++;    
            }
        } else {
            if (cursor.pos.y < lines.length - 1) {
                cursor.pos.y++;
            }
        }
        cursor.last_valid_char_pos = cursor.pos.x;
    }
    elif (vk_code == VK_UP) {
        should_reset_blink = true;
        if (cursor.pos.y > 0) {
            cursor.pos.y--;
        }
        if (!cursor.selection_active && editor_state.shift_pressed) {
            cursor.last_valid_char_pos = cursor.pos.x;
        }
    }
    elif (vk_code == VK_DOWN) {
        should_reset_blink = true;
        if (cursor.pos.y < lines.length - 1) {
            cursor.pos.y++;
        }
        if (!cursor.selection_active && editor_state.shift_pressed) {
            cursor.last_valid_char_pos = cursor.pos.x;
        }
    }
    elif (vk_code == VK_END) {
        should_reset_blink = true;
        cursor.last_valid_char_pos = current_line.length;
    }
    elif (vk_code == VK_HOME) {
        should_reset_blink = true;
        cursor.last_valid_char_pos = 0;
    }
    elif (vk_code == VK_PRIOR) {
        should_reset_blink = true;
        var delta = editor_state.render_state.visible_line_count - 2;
        if (delta <= 0) {
            delta = 1;
        }
        cursor.pos.y -= delta;
        if (cursor.pos.y < 0) {
            cursor.pos.y = 0;
        }
    }
    elif (vk_code == VK_NEXT) {
        should_reset_blink = true;
        var delta = editor_state.render_state.visible_line_count - 2;
        if (delta <= 0) {
            delta = 1;
        }
        cursor.pos.y += delta;
        if (cursor.pos.y > lines.length - 1) {
            cursor.pos.y = lines.length - 1;
        }
    }
    elif (editor_state.control_pressed && vk_code == ord("C")@i32) {
        copy_to_clipboard(&editor_state);
        should_clear_selection = false;
    }
    elif (editor_state.control_pressed &&  vk_code == ord("V")@i32) {
        should_reset_blink = true;
        if (cursor.selection_active) {
            delete_selection(&editor_state);
        }
        paste_clipboard(&editor_state);
        cursor.last_valid_char_pos = cursor.pos.x;
    }
    elif (editor_state.control_pressed && vk_code == 107) {
        editor_state.render_state.target_font_size *= 1.2;
    }
    elif (editor_state.control_pressed && vk_code == 109) {
        editor_state.render_state.target_font_size /= 1.2;
    }
    elif (editor_state.control_pressed && vk_code == ord("X")@i32) {
        var line_idx = cursor.pos.y;
        delete_line(&editor_state, line_idx);
        cursor.pos.y = Math::clamp(cursor.pos.y, 0, lines_ptr.length - 1);
        cursor.pos.x = Math::clamp(cursor.pos.x, 0, lines[cursor.pos.y].length);
    }
    else {
        should_clear_selection = false;
    }
    
    cursor.pos.y = Math::clamp(cursor.pos.y, 0, max_line_count - 1);
    cursor.pos.x = Math::clamp(cursor.last_valid_char_pos, 0, lines[cursor.pos.y].length);
    if (should_reset_blink) {
        reset_cursor_blink();
    }
    
    var has_cursor_moved = !equal(editor_state.cursor.pos, old_cursor_pos);
    var old_cursor_pos_valid = old_cursor_pos.y < lines.length && old_cursor_pos.x <= lines[old_cursor_pos.y].length;
    if (!is_printable(char@i8) && editor_state.shift_pressed && !cursor.selection_active && has_cursor_moved && old_cursor_pos_valid) {
        cursor.selection_active = true;
        cursor.selection_start = old_cursor_pos;
    }
    if (!editor_state.shift_pressed && should_clear_selection) {
        editor_state.cursor.selection_active = false;
    }
    
    current_line = lines[cursor.pos.y];
    current_line_ptr = &lines[cursor.pos.y];
    assert(current_line.length >= 0 && current_line.length < max_line_length);
    assert(cursor.pos.x <= current_line.length);
    assert(cursor.pos.y < lines_ptr.length);
    assert(lines.length <= max_line_count);
}

let handle_editor_key_up = fun(vk_code: i32) => void {
    // debug_print("key_up", vk_code);
    if (vk_code == VK_SHIFT) {
        editor_state.shift_pressed = false;
    }
    elif (vk_code == VK_CONTROL) {
        editor_state.control_pressed = false;
    }
}

[
    "compile.output": "edit.exe",
    "compile.entry" : "true",
    "compile.opt"   : "0",
    "compile.debuginfo": "true",
    "compile.ll"    : "false",
    "compile.asm"   : "false",
    "compile.cpu"   : "sandybridge", // "sandybridge",
    "compile.run"   : "true",
    "compile.libs"  : "kernel32.lib, user32.lib, gdi32.lib, shcore.lib, libopenlibm.a, opengl32.lib",
    "compile.path"  : "C:\Program Files (x86)\Windows Kits\10\Lib\10.0.14393.0\um\x64, lib"
]
let main = fun() => void {
    QueryPerformanceFrequency(&perf_count_freq);

    // SetProcessDpiAwareness(PROCESS_SYSTEM_DPI_AWARE);
    SetProcessDPIAware();

    var t0 = get_perf_counter();
    
    let buffer_width  = 1920;
    let buffer_height = 1080;
    
    var client_rect = RECT { 0, 0, buffer_width, buffer_height };
    AdjustWindowRectEx(&client_rect, dw_style, 0, dw_ex_style);

    var window_width = client_rect.right - client_rect.left;
    assert(window_width > 0);
    var window_height = client_rect.bottom - client_rect.top;
    assert(window_height > 0);
    window.client_width = buffer_width;
    window.client_height = buffer_height;
    
    var class_name  = cstr("editor_window_class\0");
    var window_name = cstr("edit\0");
    var module_handle = GetModuleHandleA(null);
    var window_class = WNDCLASSEX {};
    window_class.cbSize = size_of(WNDCLASSEX)@i32;
    window_class.style = CS_HREDRAW|CS_VREDRAW;
    window_class.lpfnWndProc = @ptr main_window_callback;
    window_class.hInstance = module_handle;
    window_class.lpszClassName = class_name;
    window_class.hCursor = LoadCursorA(null, IDC_ARROW);
    RegisterClassExA(&window_class);
    
    let dw_style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_VISIBLE;
    let dw_ex_style = 0 & WS_EX_TOPMOST;

    window.handle = CreateWindowExA(
        dw_ex_style,
        class_name,
        window_name,
        dw_style,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        window_width,
        window_height,
        null,
        null,
        module_handle,
        null
    );
    window.dc = GetDC(window.handle);

    var gl_t0 = get_perf_counter();
    init_opengl(window.dc);
    init_gl_resources();
    var gl_t1 = get_perf_counter();

    // debug_print_f64("init opengl time: ", get_seconds_elapsed(gl_t0, gl_t1));
    var frames = 0;
    
    editor_state = create_editor_state();
    var render_state = &editor_state.render_state;

    var start_time = get_perf_counter();
    while (!window.wants_to_quit) {
        process_pending_messages();
        var t0 = get_perf_counter();
        var time = get_seconds_elapsed(start_time, t0);
        render_state.delta_time = time@f32 - render_state.time;
        render_state.time = time@f32;
        render_opengl(window.client_width, window.client_height, &editor_state, window.dc);
        var t1 = get_perf_counter();
        frames++;
        if (frames == 600) {
            // debug_print("ms elapsed: ", get_seconds_elapsed(t0, t1) * 1000.0);
            frames = 0;
        }
    }
    ExitProcess(0);
}
