import "..\preamble.prag"
import "..\windows.prag"
import "..\math.prag"

import "opengl.prag"

with Windows;


let window_state = struct 
(
    handle: mm;
    dc: mm;
    client_width: i32;
    client_height: i32;
    wants_to_quit: bool;
);
var window: window_state;


let get_perf_counter = fun() => i64 {
    var result: i64;
    QueryPerformanceCounter(&result);
    return result;
}
var perf_count_freq: i64;
let get_seconds_elapsed = fun(t0: i64; t1: i64) => f64 {
    return (f64)(t1 - t0) / (f64)perf_count_freq;
}


let render_opengl = fun (@window_state: window_state*) => void {
    
    glViewport(0, 0, client_width, client_height);
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);


    glBegin(GL_TRIANGLES);
    glColor3f(1.0, 0.0, 0.0);
    glVertex3f(0.0, 1.0, 0.0);
    
    glColor3f(1.0, 1.0, 0.0);
    glVertex3f(-1.0, -1.0, 0.0);
    
    glColor3f(0.0, 0.0, 1.0);
    glVertex3f(1.0, -1.0, 0.0);
    glEnd();

    SwapBuffers(dc);
}

let process_pending_messages = fun() => void {
    var msg: MSG;
    while (PeekMessageA(&msg, null, 0, 0, PM_REMOVE|PM_NOYIELD) != 0) {
        var message = msg.message;
        if (message == WM_QUIT) {
            window.wants_to_quit = true;
        } 
        elif (message == WM_SYSKEYDOWN
            || message == WM_SYSKEYUP
            || message == WM_KEYDOWN
            || message == WM_KEYUP) {

            var w_param = (i32)(msg.wParam >> (mm)32);
            var l_param = (i32)(msg.lParam >> (mm)32);
            var vk_code = w_param;

            var was_down = (l_param & (1 << 30)) != 0;
            var is_down = (l_param & (1 << 31)) == 0;
            var key_up = was_down && !is_down;
            var key_down = !was_down && is_down; 

            if(vk_code == VK_ESCAPE) {
                window.wants_to_quit = true;
            }
        } else {
            TranslateMessage(&msg);
            DispatchMessageA(&msg);
        }
    }
}

let PROCESS_SYSTEM_DPI_AWARE = 1;
let SetProcessDpiAwareness = extern fun(
    value: i32;
) => i32;

let main_window_callback = fun
(
    window_handle: mm;
    message: i32;
    w_param: mm;
    l_param: mm;
) => mm {
    var result = null;
    if (message == WM_SIZE || message == WM_SIZING) {
    }
    elif (message == WM_CLOSE) {
        window.wants_to_quit = true;
    }
    elif (message == WM_DESTROY) {
        window.wants_to_quit = true;
    }
    elif (message == WM_PAINT) {
        var paint: PAINTSTRUCT;
        var context = BeginPaint(window_handle, &paint);
        // blit_to_screen(window.dc, &window.backbuffer);
        EndPaint(window_handle, &paint);
    } 
    else {
        result = DefWindowProcA(window_handle, message, w_param, l_param);
    }
    return result;
}


let opengl_info = struct (
    shading_language_version: string;
    vendor: string;
    renderer: string;
    version: string;
    extensions: string;
);

let get_opengl_info = fun() => opengl_info {
    var result: opengl_info;
    result.shading_language_version = from_cstr(glGetString(GL_SHADING_LANGUAGE_VERSION), -1);
    result.vendor = from_cstr(glGetString(GL_VENDOR), -1);
    result.renderer = from_cstr(glGetString(GL_RENDERER), -1);
    result.version = from_cstr(glGetString(GL_VERSION), -1);
    result.extensions = from_cstr(glGetString(GL_EXTENSIONS), -1);
    print_string("OPENGL INFO:\n");
    debug_print_string("shading language verison", result.shading_language_version);
    debug_print_string("vendor", result.vendor);
    debug_print_string("renderer", result.renderer);
    debug_print_string("version", result.version);
    debug_print_string("extensions", result.extensions);
    print_string("\n");

    var ext: string;
    ext.data = result.extensions.data;
    ext.length = 0;
    var at: i8*;    
    var ext_idx = 0;
    var ws = (i8)ord(" ");
    while (true) {
        at = ext.data;
        while (*at != ws && *at != 0) {
            at++;
            if (*at != 0) {
                ext.length++;
            }
        }
        debug_print_i32(ext, ext_idx++);

        while (*at == ws) { at++; }
        if (*at == 0) {
            print_string("break\n");
            break;
        }

        // if (strings_are_equal(ext, "EXT_texture_sRGB_decode")) {
        //      debug_print_string(ext, "true");
        // }
        
        ext.data = at;
        ext.length = 0;
    }


    return result;
}

let init_opengl = fun (window: window_state*) => void {
    var dc = window.dc;
    var pfd = PIXELFORMATDESCRIPTOR { };
    pfd.nSize = (i16)(size_of(PIXELFORMATDESCRIPTOR));
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_SUPPORT_OPENGL|PFD_DRAW_TO_WINDOW|PFD_DOUBLEBUFFER;
    pfd.cColorBits = 32;
    pfd.cAlphaBits = 8;

    var pfd_idx = ChoosePixelFormat(dc, &pfd);
    var suggested_pfd: PIXELFORMATDESCRIPTOR;
    DescribePixelFormat(dc, pfd_idx, (i32)(size_of(PIXELFORMATDESCRIPTOR)), &suggested_pfd);
    SetPixelFormat(dc, pfd_idx, &suggested_pfd);

    debug_print_i32("color_bits", (i32\)suggested_pfd.cColorBits);

    var gl_rc = wglCreateContext(dc);
    var result = wglMakeCurrent(dc, gl_rc);
    assert(result != 0);

    var wglSwapInterval: fun(value: i32) => void;
    *((ptr*)(&wglSwapInterval)) = wglGetProcAddress(cstr("wglSwapIntervalEXT\0"));
    assert((ptr)wglSwapInterval != nullptr);
    wglSwapInterval(1);
    
    var info = get_opengl_info();

}

[
	"compile.output": "opengl_test.exe",
	"compile.entry" : "true",
 	"compile.opt"   : "3",
    "compile.ll"    : "false",
    "compile.asm"   : "false",
    "compile.cpu"   : "nehalem",
 	"compile.run"   : "true",
 	"compile.libs"  : "kernel32.lib, user32.lib, gdi32.lib, shcore.lib, libopenlibm.a, opengl32.lib",
	"compile.path"  : "C:\Program Files (x86)\Windows Kits\10\Lib\10.0.14393.0\um\x64, lib"
]
let main = fun() => void {
    QueryPerformanceFrequency(&perf_count_freq);

#if TRUE
    SetProcessDpiAwareness(PROCESS_SYSTEM_DPI_AWARE);
#endif

    var t0 = get_perf_counter();
    
    let buffer_width  = 1280;
    let buffer_height = 720;

    var client_rect = RECT { 0, 0, buffer_width, buffer_height };
    AdjustWindowRectEx(&client_rect, dw_style, 0, dw_ex_style);

    var window_width = client_rect.right - client_rect.left;
    assert(window_width > 0);
    var window_height = client_rect.bottom - client_rect.top;
    assert(window_height > 0);
    window.client_width = buffer_width;
    window.client_height = buffer_height;
    
    var class_name  = cstr("opengl_test_window_class\0");
    var window_name = cstr("opengl test\0");
    var module_handle = GetModuleHandleA(null);
    var window_class = WNDCLASSEX {};
    window_class.cbSize = (i32)(size_of(WNDCLASSEX));
    window_class.style = CS_HREDRAW|CS_VREDRAW;
    window_class.lpfnWndProc = (ptr)main_window_callback;
    window_class.hInstance = module_handle;
    window_class.lpszClassName = class_name;
    window_class.hCursor = LoadCursorA(null, IDC_ARROW);
    RegisterClassExA(&window_class);
    
    let dw_style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_VISIBLE;
    let dw_ex_style = WS_EX_TOPMOST;
 
    window.handle = CreateWindowExA(
        dw_ex_style,
        class_name,
        window_name,
        dw_style,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        window_width,
        window_height,
        null,
        null,
        module_handle,
        null
    );
    window.dc = GetDC(window.handle);

    var gl_t0 = get_perf_counter();
    init_opengl(&window);
    var gl_t1 = get_perf_counter();
    
    debug_print_f64("init opengl time: ", get_seconds_elapsed(gl_t0, gl_t1));

    var frames = 0;
    while (!window.wants_to_quit) {
        var t0 = get_perf_counter();

        process_pending_messages();
        render_opengl(&window);

        var t1 = get_perf_counter();
        frames++;
        if (frames == 60) {
            var t = (f64)(t1-t0) / (f64)perf_count_freq;
            debug_print_f64("ms elapsed: ", t * 1000.0);
            frames = 0;
        }
    }

    var t1 = get_perf_counter();
    var t = (f64)(t1-t0) / (f64)perf_count_freq;
    debug_print_f64("seconds elapsed: ", t);
    ExitProcess(0);
}
